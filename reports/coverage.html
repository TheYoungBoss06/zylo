
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>zylo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zylo-lang/zylo/cmd/zylo/main.go (0.0%)</option>
				
				<option value="file1">github.com/zylo-lang/zylo/internal/ast/ast.go (0.0%)</option>
				
				<option value="file2">github.com/zylo-lang/zylo/internal/ast/func.go (0.0%)</option>
				
				<option value="file3">github.com/zylo-lang/zylo/internal/codegen/codegen.go (16.9%)</option>
				
				<option value="file4">github.com/zylo-lang/zylo/internal/evaluator/evaluator.go (0.0%)</option>
				
				<option value="file5">github.com/zylo-lang/zylo/internal/lexer/lexer.go (66.3%)</option>
				
				<option value="file6">github.com/zylo-lang/zylo/internal/lexer/token.go (0.0%)</option>
				
				<option value="file7">github.com/zylo-lang/zylo/internal/parser/parser.go (35.2%)</option>
				
				<option value="file8">github.com/zylo-lang/zylo/internal/sema/sema.go (97.5%)</option>
				
				<option value="file9">github.com/zylo-lang/zylo/runtime/runtime.go (0.0%)</option>
				
				<option value="file10">github.com/zylo-lang/zylo/test_calculator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/zylo-lang/zylo/internal/codegen"
        "github.com/zylo-lang/zylo/internal/evaluator"
        "github.com/zylo-lang/zylo/internal/lexer"
        "github.com/zylo-lang/zylo/internal/parser"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]

        switch command </span>{
        case "build":<span class="cov0" title="0">
                if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                        fmt.Println("Error: Debes especificar un archivo .zylo")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">buildFile(os.Args[2])</span>
        case "run":<span class="cov0" title="0">
                if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                        fmt.Println("Error: Debes especificar un archivo .zylo")
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">runFile(os.Args[2])</span>
        case "help":<span class="cov0" title="0">
                printUsage()</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Comando desconocido: %s\n", command)
                printUsage()
                os.Exit(1)</span>
        }
}

func printUsage() <span class="cov0" title="0">{
        fmt.Println("Uso: zylo &lt;comando&gt; [archivo]")
        fmt.Println("Comandos:")
        fmt.Println("  build &lt;archivo.zylo&gt;  - Compila un archivo Zylo a Go")
        fmt.Println("  run &lt;archivo.zylo&gt;    - Ejecuta un archivo Zylo directamente")
        fmt.Println("  help                  - Muestra esta ayuda")
}</span>

func buildFile(filename string) <span class="cov0" title="0">{
        // Verificar que el archivo existe
        if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Printf("Error: El archivo '%s' no existe\n", filename)
                os.Exit(1)
        }</span>

        // Verificar extensión
        <span class="cov0" title="0">if len(filename) &lt; 5 || filename[len(filename)-5:] != ".zylo" </span><span class="cov0" title="0">{
                fmt.Printf("Error: El archivo debe tener extensión .zylo\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Compilando %s...\n", filename)

        // Leer archivo
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error leyendo archivo: %v\n", err)
                os.Exit(1)
        }</span>

        // Parsear
        <span class="cov0" title="0">l := lexer.New(string(content))
        p := parser.New(l)
        program := p.ParseProgram()

        if len(p.Errors()) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Errores de parsing:\n")
                for _, err := range p.Errors() </span><span class="cov0" title="0">{
                        fmt.Printf("  %s\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        // Generar código Go
        <span class="cov0" title="0">cg := codegen.NewCodeGenerator()
        goCode, err := cg.Generate(program)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error generando código: %v\n", err)
                os.Exit(1)
        }</span>

        // Crear archivo de salida
        <span class="cov0" title="0">outputFile := filename[:len(filename)-5] + ".go"
        err = os.WriteFile(outputFile, []byte(goCode), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error escribiendo archivo: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Código generado en: %s\n", outputFile)
        fmt.Printf("Para ejecutar: go run %s\n", outputFile)</span>
}

func runFile(filename string) <span class="cov0" title="0">{
        // Verificar que el archivo existe
        if _, err := os.Stat(filename); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Printf("Error: El archivo '%s' no existe\n", filename)
                os.Exit(1)
        }</span>

        // Verificar extensión
        <span class="cov0" title="0">if len(filename) &lt; 5 || filename[len(filename)-5:] != ".zylo" </span><span class="cov0" title="0">{
                fmt.Printf("Error: El archivo debe tener extensión .zylo\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Ejecutando %s...\n", filename)

        // Leer archivo
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error leyendo archivo: %v\n", err)
                os.Exit(1)
        }</span>

        // Parsear
        <span class="cov0" title="0">l := lexer.New(string(content))
        p := parser.New(l)
        program := p.ParseProgram()

        if len(p.Errors()) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Errores de parsing:\n")
                for _, err := range p.Errors() </span><span class="cov0" title="0">{
                        fmt.Printf("  %s\n", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        // Debug: Imprimir AST generado
        <span class="cov0" title="0">if len(os.Args) &gt; 3 &amp;&amp; os.Args[3] == "--debug" </span><span class="cov0" title="0">{
                fmt.Printf("AST generado: %+v\n", program)
                fmt.Printf("Número de statements: %d\n", len(program.Statements))
        }</span>

        // Ejecutar directamente con el evaluador
        <span class="cov0" title="0">eval := evaluator.NewEvaluator()
        // InitBuiltins ya se llama en NewEvaluator()
        err = eval.EvaluateProgram(program)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error de ejecución: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n✅ Programa ejecutado exitosamente!")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ast

import (
        "fmt"

        "github.com/zylo-lang/zylo/internal/lexer"
)

// Node es la interfaz base para todos los nodos del AST.
type Node interface {
        TokenLiteral() string // Devuelve el literal del token asociado al nodo.
        String() string       // Devuelve una representación en string del nodo para debugging.
}

// Statement es una interfaz para todos los nodos de sentencia.
type Statement interface {
        Node
        statementNode() // Método marcador para identificar nodos de sentencia.
}

// Expression es una interfaz para todos los nodos de expresión.
type Expression interface {
        Node
        expressionNode() // Método marcador para identificar nodos de expresión.
}

// Program es el nodo raíz de todo AST de un programa Zylo.
type Program struct {
        Statements []Statement
}

func (p *Program) TokenLiteral() string <span class="cov0" title="0">{
        if len(p.Statements) &gt; 0 </span><span class="cov0" title="0">{
                return p.Statements[0].TokenLiteral()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *Program) String() string <span class="cov0" title="0">{
        var out string
        for _, s := range p.Statements </span><span class="cov0" title="0">{
                out += s.String()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// ImportStatement representa una declaración de import (e.g., import zyloruntime).
type ImportStatement struct {
        Token      lexer.Token // El token 'import'.
        ModuleName *Identifier // El nombre del módulo a importar.
}

func (is *ImportStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (is *ImportStatement) expressionNode()      {<span class="cov0" title="0">}</span> // Also implement Expression interface
func (is *ImportStatement) TokenLiteral() string <span class="cov0" title="0">{ return is.Token.Lexeme }</span>
func (is *ImportStatement) String() string <span class="cov0" title="0">{
        out := "import "
        if is.ModuleName != nil </span><span class="cov0" title="0">{
                out += is.ModuleName.String()
        }</span>
        <span class="cov0" title="0">out += ";"
        return out</span>
}

// VarStatement representa una declaración de variable (e.g., var x = 5;).
type VarStatement struct {
        Token lexer.Token // El token 'var'.
        Name  *Identifier
        Value Expression
}

func (vs *VarStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (vs *VarStatement) TokenLiteral() string <span class="cov0" title="0">{ return vs.Token.Lexeme }</span>
func (vs *VarStatement) String() string <span class="cov0" title="0">{
        var out string
        out += vs.TokenLiteral() + " "
        if vs.Name != nil </span><span class="cov0" title="0">{
                out += vs.Name.String()
        }</span>
        <span class="cov0" title="0">out += " = "
        if vs.Value != nil </span><span class="cov0" title="0">{
                out += vs.Value.String()
        }</span>
        <span class="cov0" title="0">out += ";"
        return out</span>
}

// Identifier representa un identificador en el código.
type Identifier struct {
        Token lexer.Token // El token IDENTIFIER.
        Value string
}

func (i *Identifier) expressionNode()      {<span class="cov0" title="0">}</span>
func (i *Identifier) TokenLiteral() string <span class="cov0" title="0">{ return i.Token.Lexeme }</span>
func (i *Identifier) String() string       <span class="cov0" title="0">{ return i.Value }</span>

// ExpressionStatement es una sentencia que consiste en una sola expresión.
type ExpressionStatement struct {
        Token      lexer.Token // El primer token de la expresión.
        Expression Expression
}

func (es *ExpressionStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (es *ExpressionStatement) TokenLiteral() string <span class="cov0" title="0">{ return es.Token.Lexeme }</span>
func (es *ExpressionStatement) String() string <span class="cov0" title="0">{
        if es.Expression != nil </span><span class="cov0" title="0">{
                return es.Expression.String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// FuncStatement representa una declaración de función.
type FuncStatement struct {
        Token      lexer.Token // El token 'func'.
        Name       *Identifier
        Parameters []*Identifier // Cambiado de []*Variable a []*Identifier
        ReturnType string      // Nuevo campo para el tipo de retorno
        Body       *BlockStatement
}
func (fs *FuncStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (fs *FuncStatement) TokenLiteral() string <span class="cov0" title="0">{ return fs.Token.Lexeme }</span>
func (fs *FuncStatement) String() string <span class="cov0" title="0">{
        params := []string{}
        for _, p := range fs.Parameters </span><span class="cov0" title="0">{
                params = append(params, p.String())
        }</span>
        <span class="cov0" title="0">returnType := ""
        if fs.ReturnType != "" </span><span class="cov0" title="0">{
                returnType = fmt.Sprintf(": %s", fs.ReturnType)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s %s(%s)%s %s", fs.TokenLiteral(), fs.Name.String(), formatStrings(params), returnType, fs.Body.String())</span>
}

// ReturnStatement representa una sentencia de retorno.
type ReturnStatement struct {
        Token       lexer.Token // El token 'return'.
        ReturnValue Expression
}

func (rs *ReturnStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (rs *ReturnStatement) TokenLiteral() string <span class="cov0" title="0">{ return rs.Token.Lexeme }</span>
func (rs *ReturnStatement) String() string <span class="cov0" title="0">{
        var out string
        out += rs.TokenLiteral() + " "
        if rs.ReturnValue != nil </span><span class="cov0" title="0">{
                out += rs.ReturnValue.String()
        }</span>
        <span class="cov0" title="0">out += ";"
        return out</span>
}

// BlockStatement representa un bloque de código entre llaves.
type BlockStatement struct {
        Token      lexer.Token // El token '{'.
        Statements []Statement
}

func (bs *BlockStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (bs *BlockStatement) TokenLiteral() string <span class="cov0" title="0">{ return bs.Token.Lexeme }</span>
func (bs *BlockStatement) String() string <span class="cov0" title="0">{
        var out string
        for _, s := range bs.Statements </span><span class="cov0" title="0">{
                out += s.String()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// ForInStatement representa una sentencia 'for' con iteración sobre rangos o listas.
type ForInStatement struct {
        Token      lexer.Token // El token 'for'.
        Identifier *Identifier // El identificador de la variable de iteración (e.g., 'x' in 'for x in ...').
        Iterable   Expression  // La expresión que evalúa a la lista o rango sobre el que iterar.
        Body       *BlockStatement // El cuerpo del bucle.
}

func (fs *ForInStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (fs *ForInStatement) TokenLiteral() string <span class="cov0" title="0">{ return fs.Token.Lexeme }</span>
func (fs *ForInStatement) String() string <span class="cov0" title="0">{
        out := "for "
        if fs.Identifier != nil </span><span class="cov0" title="0">{
                out += fs.Identifier.String()
        }</span>
        <span class="cov0" title="0">out += " in "
        if fs.Iterable != nil </span><span class="cov0" title="0">{
                out += fs.Iterable.String()
        }</span>
        <span class="cov0" title="0">out += " "
        if fs.Body != nil </span><span class="cov0" title="0">{
                out += fs.Body.String()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// TryStatement representa una sentencia 'try-catch'.
type TryStatement struct {
        Token       lexer.Token // El token 'try'.
        TryBlock    *BlockStatement
        CatchClause *CatchClause // Puede ser nil si solo hay finally.
        FinallyBlock *BlockStatement // Puede ser nil.
}

func (ts *TryStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (ts *TryStatement) TokenLiteral() string <span class="cov0" title="0">{ return ts.Token.Lexeme }</span>
func (ts *TryStatement) String() string <span class="cov0" title="0">{
        out := "try "
        if ts.TryBlock != nil </span><span class="cov0" title="0">{
                out += ts.TryBlock.String()
        }</span>
        <span class="cov0" title="0">if ts.CatchClause != nil </span><span class="cov0" title="0">{
                out += " " + ts.CatchClause.String()
        }</span>
        <span class="cov0" title="0">if ts.FinallyBlock != nil </span><span class="cov0" title="0">{
                out += " finally " + ts.FinallyBlock.String()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// CatchClause representa una cláusula 'catch'.
type CatchClause struct {
        Token      lexer.Token // El token 'catch'.
        Parameter  *Identifier // El identificador para la excepción capturada.
        CatchBlock *BlockStatement
}

func (cc *CatchClause) statementNode()       {<span class="cov0" title="0">}</span> // CatchClause es parte de TryStatement, no una sentencia independiente.
func (cc *CatchClause) TokenLiteral() string <span class="cov0" title="0">{ return cc.Token.Lexeme }</span>
func (cc *CatchClause) String() string <span class="cov0" title="0">{
        if cc.Parameter == nil || cc.CatchBlock == nil </span><span class="cov0" title="0">{
                return "catch (invalid) { invalid }"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("catch (%s) %s", cc.Parameter.String(), cc.CatchBlock.String())</span>
}

// ThrowStatement representa una sentencia 'throw'.
type ThrowStatement struct {
        Token     lexer.Token // El token 'throw'.
        Exception Expression
}

func (ths *ThrowStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (ths *ThrowStatement) TokenLiteral() string <span class="cov0" title="0">{ return ths.Token.Lexeme }</span>
func (ths *ThrowStatement) String() string <span class="cov0" title="0">{
        var out string
        out += ths.TokenLiteral() + " "
        if ths.Exception != nil </span><span class="cov0" title="0">{
                out += ths.Exception.String()
        }</span>
        <span class="cov0" title="0">out += ";"
        return out</span>
}

// NumberLiteral representa un literal numérico.
type NumberLiteral struct {
        Token lexer.Token
        Value interface{} // int64 or float64
}

func (nl *NumberLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (nl *NumberLiteral) TokenLiteral() string <span class="cov0" title="0">{ return nl.Token.Lexeme }</span>
func (nl *NumberLiteral) String() string       <span class="cov0" title="0">{ return nl.Token.Lexeme }</span>

// StringLiteral representa un literal de cadena.
type StringLiteral struct {
        Token lexer.Token
        Value string
}

func (sl *StringLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (sl *StringLiteral) TokenLiteral() string <span class="cov0" title="0">{ return sl.Token.Lexeme }</span>
func (sl *StringLiteral) String() string       <span class="cov0" title="0">{ return sl.Token.Lexeme }</span>

// BooleanLiteral representa un literal booleano.
type BooleanLiteral struct {
        Token lexer.Token
        Value bool
}

func (bl *BooleanLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (bl *BooleanLiteral) TokenLiteral() string <span class="cov0" title="0">{ return bl.Token.Lexeme }</span>
func (bl *BooleanLiteral) String() string       <span class="cov0" title="0">{ return bl.Token.Lexeme }</span>

// NullLiteral representa un literal null.
type NullLiteral struct {
        Token lexer.Token
}

func (nl *NullLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (nl *NullLiteral) TokenLiteral() string <span class="cov0" title="0">{ return nl.Token.Lexeme }</span>
func (nl *NullLiteral) String() string       <span class="cov0" title="0">{ return "null" }</span>

// PrefixExpression representa una expresión con un operador prefijo.
type PrefixExpression struct {
        Token    lexer.Token // El operador prefijo.
        Operator string
        Right    Expression
}

func (pe *PrefixExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (pe *PrefixExpression) TokenLiteral() string <span class="cov0" title="0">{ return pe.Token.Lexeme }</span>
func (pe *PrefixExpression) String() string <span class="cov0" title="0">{
        if pe.Right == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("(%sINVALID)", pe.Operator)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s%s)", pe.Operator, pe.Right.String())</span>
}

// InfixExpression representa una expresión con un operador infijo.
type InfixExpression struct {
        Token    lexer.Token // El operador infijo.
        Left     Expression
        Operator string
        Right    Expression
}

func (ie *InfixExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (ie *InfixExpression) TokenLiteral() string <span class="cov0" title="0">{ return ie.Token.Lexeme }</span>
func (ie *InfixExpression) String() string <span class="cov0" title="0">{
        if ie.Left == nil || ie.Right == nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("(INVALID %s INVALID)", ie.Operator)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s %s %s)", ie.Left.String(), ie.Operator, ie.Right.String())</span>
}

// CallExpression representa una llamada a función.
type CallExpression struct {
        Token     lexer.Token // El token '(' o el identificador de la función.
        Function  Expression  // La expresión que evalúa a la función.
        Arguments []Expression
}

func (ce *CallExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (ce *CallExpression) TokenLiteral() string <span class="cov0" title="0">{ return ce.Token.Lexeme }</span>
func (ce *CallExpression) String() string <span class="cov0" title="0">{
        if ce.Function == nil </span><span class="cov0" title="0">{
                return "INVALID()"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s(%s)", ce.Function.String(), formatExpressions(ce.Arguments))</span>
}

// IndexExpression representa el acceso a un índice (ej. array[index]).
type IndexExpression struct {
        Token lexer.Token // El token '['
        Left  Expression  // La expresión que evalúa al objeto indexable.
        Index Expression  // La expresión que evalúa al índice.
}

func (ie *IndexExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (ie *IndexExpression) TokenLiteral() string <span class="cov0" title="0">{ return ie.Token.Lexeme }</span>
func (ie *IndexExpression) String() string <span class="cov0" title="0">{
        if ie.Left == nil || ie.Index == nil </span><span class="cov0" title="0">{
                return "(INVALID[INVALID])"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s[%s])", ie.Left.String(), ie.Index.String())</span>
}

// MemberExpression representa el acceso a un miembro (ej. object.property).
type MemberExpression struct {
        Token    lexer.Token // El token del identificador de la propiedad.
        Object   Expression  // La expresión que evalúa al objeto.
        Property *Identifier // El identificador de la propiedad.
}

func (me *MemberExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (me *MemberExpression) TokenLiteral() string <span class="cov0" title="0">{ return me.Token.Lexeme }</span>
func (me *MemberExpression) String() string <span class="cov0" title="0">{
        if me.Object == nil || me.Property == nil </span><span class="cov0" title="0">{
                return "(INVALID.INVALID)"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s.%s)", me.Object.String(), me.Property.String())</span>
}

// BlockExpression representa un bloque de código como una expresión.
type BlockExpression struct {
        Token lexer.Token // El token '{'.
        Block *BlockStatement
}

func (be *BlockExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (be *BlockExpression) TokenLiteral() string <span class="cov0" title="0">{ return be.Token.Lexeme }</span>
func (be *BlockExpression) String() string <span class="cov0" title="0">{
        if be.Block == nil </span><span class="cov0" title="0">{
                return "{INVALID}"
        }</span>
        <span class="cov0" title="0">return be.Block.String()</span>
}

// IfStatement representa una sentencia 'if'.
type IfStatement struct {
        Token       lexer.Token     // El token 'if'.
        Condition   Expression      // La condición del if.
        Consequence *BlockStatement // El bloque del if.
        Alternative *BlockStatement // El bloque del else/elif (si existe).
        // Note: Elif se maneja como IfStatement dentro del Alternative.
}

func (is *IfStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (is *IfStatement) TokenLiteral() string <span class="cov0" title="0">{ return is.Token.Lexeme }</span>
func (is *IfStatement) String() string <span class="cov0" title="0">{
        out := "if "
        if is.Condition != nil </span><span class="cov0" title="0">{
                out += is.Condition.String()
        }</span>
        <span class="cov0" title="0">out += " "
        if is.Consequence != nil </span><span class="cov0" title="0">{
                out += is.Consequence.String()
        }</span>
        <span class="cov0" title="0">if is.Alternative != nil </span><span class="cov0" title="0">{
                out += " else " + is.Alternative.String()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// BreakStatement representa una sentencia 'break'.
type BreakStatement struct {
        Token lexer.Token // El token 'break'.
}

func (bs *BreakStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (bs *BreakStatement) TokenLiteral() string <span class="cov0" title="0">{ return bs.Token.Lexeme }</span>
func (bs *BreakStatement) String() string       <span class="cov0" title="0">{ return bs.Token.Lexeme + ";" }</span>

// ContinueStatement representa una sentencia 'continue'.
type ContinueStatement struct {
        Token lexer.Token // El token 'continue'.
}

func (cs *ContinueStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (cs *ContinueStatement) TokenLiteral() string <span class="cov0" title="0">{ return cs.Token.Lexeme }</span>
func (cs *ContinueStatement) String() string       <span class="cov0" title="0">{ return cs.Token.Lexeme + ";" }</span>

// WhileStatement representa una sentencia 'while'.
type WhileStatement struct {
        Token     lexer.Token // El token 'while'.
        Condition Expression  // La condición del bucle.
        Body      *BlockStatement // El cuerpo del bucle.
}

func (ws *WhileStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (ws *WhileStatement) TokenLiteral() string <span class="cov0" title="0">{ return ws.Token.Lexeme }</span>
func (ws *WhileStatement) String() string <span class="cov0" title="0">{
        out := "while "
        if ws.Condition != nil </span><span class="cov0" title="0">{
                out += ws.Condition.String()
        }</span>
        <span class="cov0" title="0">out += " "
        if ws.Body != nil </span><span class="cov0" title="0">{
                out += ws.Body.String()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// ClassStatement representa una declaración de clase.
type ClassStatement struct {
        Token      lexer.Token // El token 'class'.
        Name       *Identifier
        Attributes []*VarStatement // Atributos de la clase
        Methods    []*FuncStatement // Métodos de la clase
        InitMethod *FuncStatement // Método constructor (init)
}

func (cs *ClassStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (cs *ClassStatement) TokenLiteral() string <span class="cov0" title="0">{ return cs.Token.Lexeme }</span>
func (cs *ClassStatement) String() string <span class="cov0" title="0">{
        out := "class "
        if cs.Name != nil </span><span class="cov0" title="0">{
                out += cs.Name.String()
        }</span>
        <span class="cov0" title="0">out += " {\n"
        for _, attr := range cs.Attributes </span><span class="cov0" title="0">{
                out += "    " + attr.String() + "\n"
        }</span>
        <span class="cov0" title="0">for _, method := range cs.Methods </span><span class="cov0" title="0">{
                out += "    " + method.String() + "\n"
        }</span>
        <span class="cov0" title="0">out += "}"
        return out</span>
}

// ListLiteral representa un literal de lista (e.g., [1, 2, 3]).
type ListLiteral struct {
        Token    lexer.Token // El token '['.
        Elements []Expression
}

func (ll *ListLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (ll *ListLiteral) TokenLiteral() string <span class="cov0" title="0">{ return ll.Token.Lexeme }</span>
func (ll *ListLiteral) String() string <span class="cov0" title="0">{
        if ll.Elements == nil </span><span class="cov0" title="0">{
                return "[]"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("[%s]", formatExpressions(ll.Elements))</span>
}
// HashLiteral representa un literal de hash (e.g., {key: value}).
type HashLiteral struct {
        Token lexer.Token // El token '{'.
        Pairs map[Expression]Expression
}

func (hl *HashLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (hl *HashLiteral) TokenLiteral() string <span class="cov0" title="0">{ return hl.Token.Lexeme }</span>
func (hl *HashLiteral) String() string <span class="cov0" title="0">{
        if hl.Pairs == nil </span><span class="cov0" title="0">{
                return "{}"
        }</span>
        <span class="cov0" title="0">var pairs []string
        for key, value := range hl.Pairs </span><span class="cov0" title="0">{
                pairs = append(pairs, fmt.Sprintf("%s: %s", key.String(), value.String()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("{%s}", formatStrings(pairs))</span>
}

// ClassInstantiation representa la instanciación de una clase (e.g., Persona("Wilson", 25)).
type ClassInstantiation struct {
        Token     lexer.Token // El token de la clase.
        ClassName *Identifier
        Arguments []Expression
}

func (ci *ClassInstantiation) expressionNode()      {<span class="cov0" title="0">}</span>
func (ci *ClassInstantiation) TokenLiteral() string <span class="cov0" title="0">{ return ci.Token.Lexeme }</span>
func (ci *ClassInstantiation) String() string <span class="cov0" title="0">{
        if ci.ClassName == nil </span><span class="cov0" title="0">{
                return "INVALID()"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s(%s)", ci.ClassName.String(), formatExpressions(ci.Arguments))</span>
}

// ThisExpression representa la expresión 'this'
type ThisExpression struct {
        Token lexer.Token // El token 'this'.
}

func (te *ThisExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (te *ThisExpression) TokenLiteral() string <span class="cov0" title="0">{ return te.Token.Lexeme }</span>
func (te *ThisExpression) String() string       <span class="cov0" title="0">{ return "this" }</span>

// Helper para formatear listas de expresiones en strings.
func formatExpressions(exps []Expression) string <span class="cov0" title="0">{
        var parts []string
        for _, exp := range exps </span><span class="cov0" title="0">{
                parts = append(parts, exp.String())
        }</span>
        <span class="cov0" title="0">return formatStrings(parts)</span>
}

func formatStrings(strs []string) string <span class="cov0" title="0">{
        var result string
        for i, s := range strs </span><span class="cov0" title="0">{
                result += s
                if i &lt; len(strs)-1 </span><span class="cov0" title="0">{
                        result += ", "
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ast

import (
        "fmt"

        "github.com/zylo-lang/zylo/internal/lexer"
)

// Variable representa una variable (usada para parámetros de función).
type Variable struct {
        Token lexer.Token // El token IDENTIFIER.
        Name  string
        Type  string // Anotación de tipo opcional.
}

// expressionNode implementa la interfaz Expression.
func (v *Variable) expressionNode() {<span class="cov0" title="0">}</span>

// TokenLiteral devuelve el literal del token de la variable.
func (v *Variable) TokenLiteral() string <span class="cov0" title="0">{ return v.Token.Lexeme }</span>

// String devuelve una representación en string de la variable.
func (v *Variable) String() string <span class="cov0" title="0">{
        if v.Type != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s", v.Name, v.Type)
        }</span>
        <span class="cov0" title="0">return v.Name</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package codegen

import (
        "fmt"
        "strings"

        "github.com/zylo-lang/zylo/internal/ast"
)

// CodeGenerator es el struct principal para la generación de código Go.
type CodeGenerator struct {
        output      strings.Builder
        indentation int
        classNames  []string
}

// NewCodeGenerator crea un nuevo CodeGenerator.
func NewCodeGenerator() *CodeGenerator <span class="cov8" title="1">{
        return &amp;CodeGenerator{classNames: make([]string, 0)}
}</span>

// Generate genera código Go a partir de un AST.
func (cg *CodeGenerator) Generate(program *ast.Program) (string, error) <span class="cov8" title="1">{
        if program == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("program is nil")
        }</span>

        <span class="cov8" title="1">cg.writeString("package main\n\n")
        cg.writeString("import (\n")
        cg.writeString("    \"fmt\"\n")
        cg.writeString(")\n\n")

        // First pass: generate all function and class declarations
        for _, stmt := range program.Statements </span><span class="cov8" title="1">{
                if stmt != nil </span><span class="cov8" title="1">{
                        if funcStmt, ok := stmt.(*ast.FuncStatement); ok </span><span class="cov0" title="0">{
                                if funcStmt.Name.Value != "main" </span><span class="cov0" title="0">{
                                        cg.generateStatement(stmt)
                                }</span>
                        } else<span class="cov8" title="1"> if classStmt, ok := stmt.(*ast.ClassStatement); ok </span><span class="cov0" title="0">{
                                cg.classNames = append(cg.classNames, classStmt.Name.Value)
                                cg.generateStatement(stmt)
                        }</span>
                }
        }

        // Generate main function with executable statements
        <span class="cov8" title="1">cg.writeString("func main() {\n")
        cg.indent()

        for _, stmt := range program.Statements </span><span class="cov8" title="1">{
                // Skip function and class declarations in main
                if stmt != nil </span><span class="cov8" title="1">{
                        if _, ok := stmt.(*ast.FuncStatement); ok </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov8" title="1"> if _, ok := stmt.(*ast.ClassStatement); ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">cg.generateStatement(stmt)</span>
                }
        }

        <span class="cov8" title="1">cg.dedent()
        cg.writeString("}\n")

        return cg.output.String(), nil</span>
}

// generateBreakStatement genera código Go para una sentencia 'break'.
func (cg *CodeGenerator) generateBreakStatement(stmt *ast.BreakStatement) <span class="cov0" title="0">{
        cg.writeString("break\n")
}</span>

// generateContinueStatement genera código Go para una sentencia 'continue'.
func (cg *CodeGenerator) generateContinueStatement(stmt *ast.ContinueStatement) <span class="cov0" title="0">{
        cg.writeString("continue\n")
}</span>

// generateForInStatement genera código Go para una sentencia 'for in'.
func (cg *CodeGenerator) generateForInStatement(stmt *ast.ForInStatement) <span class="cov0" title="0">{
        cg.writeString(fmt.Sprintf("for _, %s := range ", stmt.Identifier.Value))
        cg.generateExpression(stmt.Iterable)
        cg.writeString(" {\n")
        cg.indent()

        if stmt.Body != nil </span><span class="cov0" title="0">{
                for _, bodyStmt := range stmt.Body.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}\n")</span>
}

// generateStatement genera código Go para una sentencia del AST.
func (cg *CodeGenerator) generateStatement(stmt ast.Statement) <span class="cov8" title="1">{
        if stmt == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">switch s := stmt.(type) </span>{
        case *ast.VarStatement:<span class="cov8" title="1">
                if s != nil </span><span class="cov8" title="1">{
                        cg.generateVarStatement(s)
                }</span>
        case *ast.ExpressionStatement:<span class="cov8" title="1">
                if s != nil </span><span class="cov8" title="1">{
                        cg.generateExpressionStatement(s)
                }</span>
        case *ast.FuncStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateFuncStatement(s)
                }</span>
        case *ast.ReturnStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateReturnStatement(s)
                }</span>
        case *ast.IfStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateIfStatement(s)
                }</span>
        case *ast.WhileStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateWhileStatement(s)
                }</span>
        case *ast.ForInStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateForInStatement(s)
                }</span>
        case *ast.TryStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateTryStatement(s)
                }</span>
        case *ast.ThrowStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateThrowStatement(s)
                }</span>
        case *ast.BlockStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateBlockStatement(s)
                }</span>
        case *ast.BreakStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateBreakStatement(s)
                }</span>
        case *ast.ContinueStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateContinueStatement(s)
                }</span>
        case *ast.ClassStatement:<span class="cov0" title="0">
                if s != nil </span><span class="cov0" title="0">{
                        cg.generateClassStatement(s)
                }</span>
        default:<span class="cov0" title="0">
                // TODO: Manejar otros tipos de sentencias.
                cg.writeString(fmt.Sprintf("// TODO: Sentencia no soportada: %T\n", s))</span>
        }
}

// generateWhileStatement genera código Go para una sentencia 'while'.
func (cg *CodeGenerator) generateWhileStatement(stmt *ast.WhileStatement) <span class="cov0" title="0">{
        cg.writeString("for ")
        cg.generateExpression(stmt.Condition)
        cg.writeString(" {\n")
        cg.indent()

        if stmt.Body != nil </span><span class="cov0" title="0">{
                for _, bodyStmt := range stmt.Body.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}\n")</span>
}

// generateVarStatement genera código Go para una declaración de variable.
func (cg *CodeGenerator) generateVarStatement(stmt *ast.VarStatement) <span class="cov8" title="1">{
        cg.writeString(fmt.Sprintf("var %s ", stmt.Name.Value))
        if stmt.Value != nil </span><span class="cov8" title="1">{
                cg.writeString("= ")
                cg.generateExpression(stmt.Value)
        }</span> else <span class="cov0" title="0">{
                // Si no hay valor, declarar con el tipo cero (implícito en Go).
                // Para Zylo, podríamos necesitar un tipo explícito o inferir "any".
                // Por ahora, dejamos que Go maneje el tipo cero.
        }</span>
        <span class="cov8" title="1">cg.writeString("\n")</span>
}

// generateExpressionStatement genera código Go para una sentencia de expresión.
func (cg *CodeGenerator) generateExpressionStatement(stmt *ast.ExpressionStatement) <span class="cov8" title="1">{
        // CRÍTICO: Verificar que stmt y stmt.Expression no sean nil
        if stmt == nil || stmt.Expression == nil </span><span class="cov0" title="0">{
                return // No generar nada si no hay expresión
        }</span>
        <span class="cov8" title="1">if _, ok := stmt.Expression.(*ast.NumberLiteral); ok </span><span class="cov0" title="0">{
                return // Skip standalone number literals
        }</span>
        <span class="cov8" title="1">cg.generateExpression(stmt.Expression)
        cg.writeString("\n")</span>
}

// generateFuncStatement genera código Go para una declaración de función.
func (cg *CodeGenerator) generateFuncStatement(stmt *ast.FuncStatement) <span class="cov0" title="0">{
        if stmt == nil || stmt.Name == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cg.writeString(fmt.Sprintf("func %s(", stmt.Name.Value))

        // Generar parámetros
        for i, param := range stmt.Parameters </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        cg.writeString(", ")
                }</span>
                <span class="cov0" title="0">if param != nil </span><span class="cov0" title="0">{
                        cg.writeString(fmt.Sprintf("%s int", param.Value))
                }</span>
        }

        // Generar tipo de retorno
                <span class="cov0" title="0">returnType := " int"
                if stmt.ReturnType != "" </span><span class="cov0" title="0">{
                        returnType = fmt.Sprintf(" %s", stmt.ReturnType)
                }</span>

        <span class="cov0" title="0">cg.writeString(fmt.Sprintf(")%s {\n", returnType))
        cg.indent()

        // Generar cuerpo de la función
        if stmt.Body != nil </span><span class="cov0" title="0">{
                for _, bodyStmt := range stmt.Body.Statements </span><span class="cov0" title="0">{
                        if bodyStmt != nil </span><span class="cov0" title="0">{
                                cg.generateStatement(bodyStmt)
                        }</span>
                }
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}\n")</span>
}

// generateExpression genera código Go para una expresión del AST.
func (cg *CodeGenerator) generateExpression(exp ast.Expression) <span class="cov8" title="1">{
        if exp == nil </span><span class="cov0" title="0">{
                cg.writeString("// TODO: Expresión no soportada: &lt;nil&gt;")
                return
        }</span>

        <span class="cov8" title="1">switch e := exp.(type) </span>{
        case *ast.Identifier:<span class="cov8" title="1">
                if e.Value == "HASH_LITERAL" </span><span class="cov0" title="0">{
                        cg.writeString("make(map[string]interface{})")
                }</span> else<span class="cov8" title="1"> {
                        cg.writeString(e.Value)
                }</span>
        case *ast.StringLiteral:<span class="cov8" title="1">
                cg.writeString(fmt.Sprintf("%q", e.Value))</span>
        case *ast.NumberLiteral:<span class="cov0" title="0">
                cg.writeString(fmt.Sprintf("%d", e.Value))</span> // Asumiendo int64 por ahora
        case *ast.BooleanLiteral:<span class="cov0" title="0">
                if e.Value </span><span class="cov0" title="0">{
                        cg.writeString("true")
                }</span> else<span class="cov0" title="0"> {
                        cg.writeString("false")
                }</span>
        case *ast.ListLiteral:<span class="cov0" title="0">
                cg.writeString("zyloruntime.NewList()")
                for _, element := range e.Elements </span><span class="cov0" title="0">{
                        cg.writeString(".Append(")
                        cg.generateExpression(element)
                        cg.writeString(")")
                }</span>
        case *ast.HashLiteral:<span class="cov0" title="0">
                cg.writeString("make(map[string]interface{})")</span>
        case *ast.ClassInstantiation:<span class="cov0" title="0">
                // For now, treat as a function call to the class constructor
                if e.ClassName != nil </span><span class="cov0" title="0">{
                        cg.writeString(fmt.Sprintf("New%s(", e.ClassName.Value))
                        for i, arg := range e.Arguments </span><span class="cov0" title="0">{
                                cg.generateExpression(arg)
                                if i &lt; len(e.Arguments)-1 </span><span class="cov0" title="0">{
                                        cg.writeString(", ")
                                }</span>
                        }
                        <span class="cov0" title="0">cg.writeString(")")</span>
                }
        case *ast.CallExpression:<span class="cov8" title="1">
                // Manejar funciones especiales del runtime
                if ident, ok := e.Function.(*ast.Identifier); ok </span><span class="cov8" title="1">{
                        switch ident.Value </span>{
                        case "show.log":<span class="cov0" title="0">
                                cg.writeString("fmt.Println(") // Usar fmt.Println
                                for i, arg := range e.Arguments </span><span class="cov0" title="0">{
                                        if arg != nil </span><span class="cov0" title="0">{
                                                cg.generateExpression(arg)
                                        }</span>
                                        <span class="cov0" title="0">if i &lt; len(e.Arguments)-1 </span><span class="cov0" title="0">{
                                                cg.writeString(", ")
                                        }</span>
                                }
                                <span class="cov0" title="0">cg.writeString(")")</span>
                        case "read.line":<span class="cov0" title="0">
                                cg.writeString("fmt.Scanln()")</span>
                        case "read.int":<span class="cov0" title="0">
                                cg.writeString("fmt.Scanf(\"%d\")")</span>
                        default:<span class="cov8" title="1">
                                // Si es una llamada a una función definida por el usuario, simplemente llamarla.
                                oldIndent := cg.indentation
                                cg.indentation = 0
                                cg.generateExpression(e.Function)
                                cg.writeString("(")
                                for i, arg := range e.Arguments </span><span class="cov8" title="1">{
                                        if arg != nil </span><span class="cov8" title="1">{
                                                cg.generateExpression(arg)
                                        }</span>
                                        <span class="cov8" title="1">if i &lt; len(e.Arguments)-1 </span><span class="cov0" title="0">{
                                                cg.writeString(", ")
                                        }</span>
                                }
                                <span class="cov8" title="1">cg.writeString(")")
                                cg.indentation = oldIndent</span>
                        }
                } else<span class="cov0" title="0"> if member, ok := e.Function.(*ast.MemberExpression); ok </span><span class="cov0" title="0">{
                        // Handle member access calls like obj.method(...)
                        if member.Object != nil &amp;&amp; member.Property != nil </span><span class="cov0" title="0">{
                                // Generate as obj.method(...)
                                oldIndent := cg.indentation
                                cg.indentation = 0
                                cg.generateExpression(e.Function)
                                cg.writeString("(")
                                for i, arg := range e.Arguments </span><span class="cov0" title="0">{
                                        if arg != nil </span><span class="cov0" title="0">{
                                                cg.generateExpression(arg)
                                        }</span>
                                        <span class="cov0" title="0">if i &lt; len(e.Arguments)-1 </span><span class="cov0" title="0">{
                                                cg.writeString(", ")
                                        }</span>
                                }
                                <span class="cov0" title="0">cg.writeString(")")
                                cg.indentation = oldIndent</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Check if it's a class instantiation
                        if ident, ok := e.Function.(*ast.Identifier); ok </span><span class="cov0" title="0">{
                                for _, class := range cg.classNames </span><span class="cov0" title="0">{
                                        if ident.Value == class </span><span class="cov0" title="0">{
                                                cg.writeString(fmt.Sprintf("New%s(", class))
                                                for i, arg := range e.Arguments </span><span class="cov0" title="0">{
                                                        if arg != nil </span><span class="cov0" title="0">{
                                                                cg.generateExpression(arg)
                                                        }</span>
                                                        <span class="cov0" title="0">if i &lt; len(e.Arguments)-1 </span><span class="cov0" title="0">{
                                                                cg.writeString(", ")
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">cg.writeString(")")
                                                return</span>
                                        }
                                }
                        }

                        // Handle other function calls
                        <span class="cov0" title="0">cg.generateExpression(e.Function)
                        cg.writeString("(")
                        for i, arg := range e.Arguments </span><span class="cov0" title="0">{
                                if arg != nil </span><span class="cov0" title="0">{
                                        cg.generateExpression(arg)
                                }</span>
                                <span class="cov0" title="0">if i &lt; len(e.Arguments)-1 </span><span class="cov0" title="0">{
                                        cg.writeString(", ")
                                }</span>
                        }
                        <span class="cov0" title="0">cg.writeString(")")</span>
                }
        case *ast.InfixExpression:<span class="cov0" title="0">
                cg.generateInfixExpression(e)</span>
        case *ast.MemberExpression:<span class="cov0" title="0">
                // Handle special cases like show.log()
                if e.Object != nil &amp;&amp; e.Property != nil </span><span class="cov0" title="0">{
                        if objId, ok := e.Object.(*ast.Identifier); ok &amp;&amp; objId.Value == "show" </span><span class="cov0" title="0">{
                                if e.Property.Value == "log" </span><span class="cov0" title="0">{
                                        cg.writeString("fmt.Println")
                                        return
                                }</span>
                        }
                }

                // Generate member expression without intermediate indentation
                <span class="cov0" title="0">oldIndent := cg.indentation
                cg.indentation = 0
                if e.Object != nil </span><span class="cov0" title="0">{
                        cg.generateExpression(e.Object)
                }</span>
                <span class="cov0" title="0">cg.writeString(".")
                if e.Property != nil </span><span class="cov0" title="0">{
                        cg.writeString(e.Property.Value)
                }</span>
                <span class="cov0" title="0">cg.indentation = oldIndent</span>
        case *ast.ThisExpression:<span class="cov0" title="0">
                cg.generateThisExpression(e)</span>
        default:<span class="cov0" title="0">
                // TODO: Manejar otros tipos de expresiones.
                cg.writeString(fmt.Sprintf("// TODO: Expresión no soportada: %T", e))</span>
        }
}

// generateReturnStatement genera código Go para una sentencia de retorno.
func (cg *CodeGenerator) generateReturnStatement(stmt *ast.ReturnStatement) <span class="cov0" title="0">{
        cg.writeString("return")
        if stmt.ReturnValue != nil </span><span class="cov0" title="0">{
                cg.writeString(" ")
                cg.generateExpression(stmt.ReturnValue)
        }</span>
        <span class="cov0" title="0">cg.writeString("\n")</span>
}

// generateIfStatement genera código Go para una sentencia 'if'.
func (cg *CodeGenerator) generateIfStatement(stmt *ast.IfStatement) <span class="cov0" title="0">{
        cg.writeString("if ")
        cg.generateExpression(stmt.Condition)
        cg.writeString(" {\n")
        cg.indent()

        if stmt.Consequence != nil </span><span class="cov0" title="0">{
                for _, bodyStmt := range stmt.Consequence.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}")

        if stmt.Alternative != nil </span><span class="cov0" title="0">{
                cg.writeString(" else {\n")
                cg.indent()

                for _, bodyStmt := range stmt.Alternative.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>

                <span class="cov0" title="0">cg.dedent()
                cg.writeString("}")</span>
        }
        <span class="cov0" title="0">cg.writeString("\n")</span>
}

// generateTryStatement genera código Go para una sentencia 'try-catch'.
func (cg *CodeGenerator) generateTryStatement(stmt *ast.TryStatement) <span class="cov0" title="0">{
        cg.writeString("zyloruntime.Try(func() {\n")
        cg.indent()

        if stmt.TryBlock != nil </span><span class="cov0" title="0">{
                for _, bodyStmt := range stmt.TryBlock.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}, func(err error) {\n")
        cg.indent()

        if stmt.CatchClause != nil &amp;&amp; stmt.CatchClause.CatchBlock != nil </span><span class="cov0" title="0">{
                // Declarar la variable de error si hay un parámetro
                if stmt.CatchClause.Parameter != nil </span><span class="cov0" title="0">{
                        cg.writeString(fmt.Sprintf("var %s = err\n", stmt.CatchClause.Parameter.Value)) // Usar param.Value
                }</span>

                <span class="cov0" title="0">for _, bodyStmt := range stmt.CatchClause.CatchBlock.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("})\n")

        // Manejar finally block si existe
        if stmt.FinallyBlock != nil </span><span class="cov0" title="0">{
                cg.writeString("defer func() {\n")
                cg.indent()

                for _, bodyStmt := range stmt.FinallyBlock.Statements </span><span class="cov0" title="0">{
                        cg.generateStatement(bodyStmt)
                }</span>

                <span class="cov0" title="0">cg.dedent()
                cg.writeString("}()\n")</span>
        }
}

// generateThrowStatement genera código Go para una sentencia 'throw'.
func (cg *CodeGenerator) generateThrowStatement(stmt *ast.ThrowStatement) <span class="cov0" title="0">{
        cg.writeString("zyloruntime.Throw(")
        if stmt.Exception != nil </span><span class="cov0" title="0">{
                cg.generateExpression(stmt.Exception)
        }</span> else<span class="cov0" title="0"> {
                cg.writeString("\"\"")
        }</span>
        <span class="cov0" title="0">cg.writeString(")\n")</span>
}

// generateBlockStatement genera código Go para un bloque de sentencias.
func (cg *CodeGenerator) generateBlockStatement(stmt *ast.BlockStatement) <span class="cov0" title="0">{
        cg.writeString("{\n")
        cg.indent()

        for _, bodyStmt := range stmt.Statements </span><span class="cov0" title="0">{
                cg.generateStatement(bodyStmt)
        }</span>

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}\n")</span>
}

// writeString escribe una cadena en la salida con la indentación actual.
func (cg *CodeGenerator) writeString(s string) <span class="cov8" title="1">{
        if len(s) &gt; 0 &amp;&amp; s[0] != '\n' </span><span class="cov8" title="1">{ // No indentar si la línea comienza con un salto de línea
                for i := 0; i &lt; cg.indentation; i++ </span><span class="cov8" title="1">{
                        cg.output.WriteString("    ") // 4 espacios por nivel de indentación
                }</span>
        }
        <span class="cov8" title="1">cg.output.WriteString(s)</span>
}

// indent aumenta el nivel de indentación.
func (cg *CodeGenerator) indent() <span class="cov8" title="1">{
        cg.indentation++
}</span>

// dedent disminuye el nivel de indentación.
func (cg *CodeGenerator) dedent() <span class="cov8" title="1">{
        if cg.indentation &gt; 0 </span><span class="cov8" title="1">{
                cg.indentation--
        }</span>
}

// generateClassStatement genera código Go para una declaración de clase.
func (cg *CodeGenerator) generateClassStatement(stmt *ast.ClassStatement) <span class="cov0" title="0">{
        if stmt.Name == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">className := stmt.Name.Value

        // Generate struct definition
        cg.writeString(fmt.Sprintf("type %s struct {\n", className))
        cg.indent()

        // Generate attributes
        for _, attr := range stmt.Attributes </span><span class="cov0" title="0">{
                if attr.Name != nil </span><span class="cov0" title="0">{
                        cg.writeString(fmt.Sprintf("%s interface{}\n", attr.Name.Value))
                }</span>
        }

        <span class="cov0" title="0">cg.dedent()
        cg.writeString("}\n\n")

        // Generate constructor function
                cg.writeString(fmt.Sprintf("func New%s(", className))
                // Add parameters for init method if it exists
                if stmt.InitMethod != nil &amp;&amp; len(stmt.InitMethod.Parameters) &gt; 0 </span><span class="cov0" title="0">{
                        for i, param := range stmt.InitMethod.Parameters </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        cg.writeString(", ")
                                }</span>
                                <span class="cov0" title="0">cg.writeString(fmt.Sprintf("%s int", param.Value))</span>
                        }
                }
        <span class="cov0" title="0">cg.writeString(fmt.Sprintf(") *%s {\n", className))
        cg.indent()

        cg.writeString(fmt.Sprintf("obj := &amp;%s{}\n", className))

        // Call init method if it exists
        if stmt.InitMethod != nil </span><span class="cov0" title="0">{
                cg.writeString(fmt.Sprintf("obj.%s(", stmt.InitMethod.Name.Value))
                if len(stmt.InitMethod.Parameters) &gt; 0 </span><span class="cov0" title="0">{
                        for i, param := range stmt.InitMethod.Parameters </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        cg.writeString(", ")
                                }</span>
                                <span class="cov0" title="0">cg.writeString(param.Value)</span>
                        }
                }
                <span class="cov0" title="0">cg.writeString(")\n")</span>
        }

        <span class="cov0" title="0">cg.writeString("return obj\n")
        cg.dedent()
        cg.writeString("}\n\n")

        // Generate methods
        for _, method := range stmt.Methods </span><span class="cov0" title="0">{
                if method.Name == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">cg.writeString(fmt.Sprintf("func (obj *%s) %s(", className, method.Name.Value))

                // Add parameters
                                for i, param := range method.Parameters </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                cg.writeString(", ")
                                        }</span>
                                        <span class="cov0" title="0">cg.writeString(fmt.Sprintf("%s int", param.Value))</span>
                                }

                <span class="cov0" title="0">cg.writeString(")")

                // Add return type if specified
                if method.ReturnType != "" </span><span class="cov0" title="0">{
                        cg.writeString(fmt.Sprintf(" %s", method.ReturnType))
                }</span>

                <span class="cov0" title="0">cg.writeString(" {\n")
                cg.indent()

                // Generate method body
                if method.Body != nil </span><span class="cov0" title="0">{
                        for _, bodyStmt := range method.Body.Statements </span><span class="cov0" title="0">{
                                cg.generateStatement(bodyStmt)
                        }</span>
                }

                <span class="cov0" title="0">cg.dedent()
                cg.writeString("}\n\n")</span>
        }
}

// generateInfixExpression genera código Go para una expresión infija
func (cg *CodeGenerator) generateInfixExpression(exp *ast.InfixExpression) <span class="cov0" title="0">{
        // Manejar expresiones infijas con operadores correctos
        if exp == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if exp.Operator == "=" </span><span class="cov0" title="0">{
                if exp.Left != nil </span><span class="cov0" title="0">{
                        cg.generateExpression(exp.Left)
                }</span>
                <span class="cov0" title="0">cg.writeString(" = ")
                if exp.Right != nil </span><span class="cov0" title="0">{
                        cg.generateExpression(exp.Right)
                }</span>
        } else<span class="cov0" title="0"> {
                if exp.Operator == "+" </span><span class="cov0" title="0">{
                        cg.writeString("fmt.Sprintf(\"%v%v\", ")
                        if exp.Left != nil </span><span class="cov0" title="0">{
                                cg.generateExpression(exp.Left)
                        }</span> else<span class="cov0" title="0"> {
                                cg.writeString("nil")
                        }</span>
                        <span class="cov0" title="0">cg.writeString(", ")
                        if exp.Right != nil </span><span class="cov0" title="0">{
                                cg.generateExpression(exp.Right)
                        }</span> else<span class="cov0" title="0"> {
                                cg.writeString("nil")
                        }</span>
                        <span class="cov0" title="0">cg.writeString(")")</span>
                } else<span class="cov0" title="0"> {
                        if exp.Left != nil </span><span class="cov0" title="0">{
                                cg.generateExpression(exp.Left)
                        }</span> else<span class="cov0" title="0"> {
                                cg.writeString("nil")
                        }</span>

                        // Convertir operadores de Zylo a Go
                        <span class="cov0" title="0">switch exp.Operator </span>{
                        case "==":<span class="cov0" title="0">
                                cg.writeString(" == ")</span>
                        case "!=":<span class="cov0" title="0">
                                cg.writeString(" != ")</span>
                        case "-":<span class="cov0" title="0">
                                cg.writeString(" - ")</span>
                        case "*":<span class="cov0" title="0">
                                cg.writeString(" * ")</span>
                        case "/":<span class="cov0" title="0">
                                cg.writeString(" / ")</span>
                        case "&lt;":<span class="cov0" title="0">
                                cg.writeString(" &lt; ")</span>
                        case "&gt;":<span class="cov0" title="0">
                                cg.writeString(" &gt; ")</span>
                        case "&lt;=":<span class="cov0" title="0">
                                cg.writeString(" &lt;= ")</span>
                        case "&gt;=":<span class="cov0" title="0">
                                cg.writeString(" &gt;= ")</span>
                        case "&amp;&amp;":<span class="cov0" title="0">
                                cg.writeString(" &amp;&amp; ")</span>
                        case "||":<span class="cov0" title="0">
                                cg.writeString(" || ")</span>
                        default:<span class="cov0" title="0">
                                cg.writeString(" " + exp.Operator + " ")</span>
                        }

                        <span class="cov0" title="0">if exp.Right != nil </span><span class="cov0" title="0">{
                                cg.generateExpression(exp.Right)
                        }</span> else<span class="cov0" title="0"> {
                                cg.writeString("nil")
                        }</span>
                }
        }
}

// generateThisExpression genera código Go para una expresión 'this'
func (cg *CodeGenerator) generateThisExpression(exp *ast.ThisExpression) <span class="cov0" title="0">{
        cg.writeString("obj")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package evaluator

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/zylo-lang/zylo/internal/ast"
)

// ZyloObject representa un objeto en tiempo de ejecución de Zylo
type ZyloObject interface {
        Type() string
        Inspect() string
}

// String representa un objeto string
type String struct {
        Value string
}

func (s *String) Type() string    <span class="cov0" title="0">{ return "STRING_OBJ" }</span>
func (s *String) Inspect() string <span class="cov0" title="0">{ return s.Value }</span>

// Integer representa un objeto integer
type Integer struct {
        Value int64
}

func (i *Integer) Type() string    <span class="cov0" title="0">{ return "INTEGER_OBJ" }</span>
func (i *Integer) Inspect() string <span class="cov0" title="0">{ return fmt.Sprintf("%d", i.Value) }</span>

// Float representa un objeto float
type Float struct {
        Value float64
}

func (f *Float) Type() string    <span class="cov0" title="0">{ return "FLOAT_OBJ" }</span>
func (f *Float) Inspect() string <span class="cov0" title="0">{ return fmt.Sprintf("%g", f.Value) }</span>

// List representa un objeto list
type List struct {
        Items []Value
}

func (l *List) Type() string <span class="cov0" title="0">{ return "LIST_OBJ" }</span>
func (l *List) Inspect() string <span class="cov0" title="0">{
        parts := make([]string, len(l.Items))
        for i, el := range l.Items </span><span class="cov0" title="0">{
                if obj, ok := el.(ZyloObject); ok </span><span class="cov0" title="0">{
                        parts[i] = obj.Inspect()
                }</span> else<span class="cov0" title="0"> {
                        parts[i] = fmt.Sprintf("%v", el)
                }</span>
        }
        <span class="cov0" title="0">return "[" + strings.Join(parts, ", ") + "]"</span>
}
// Hash representa un objeto hash
type Hash struct {
        Pairs map[string]Value
}

func (h *Hash) Type() string <span class="cov0" title="0">{ return "HASH_OBJ" }</span>
func (h *Hash) Inspect() string <span class="cov0" title="0">{
        var pairs []string
        for key, value := range h.Pairs </span><span class="cov0" title="0">{
                if obj, ok := value.(ZyloObject); ok </span><span class="cov0" title="0">{
                        pairs = append(pairs, fmt.Sprintf("%s: %s", key, obj.Inspect()))
                }</span> else<span class="cov0" title="0"> {
                        pairs = append(pairs, fmt.Sprintf("%s: %v", key, value))
                }</span>
        }
        <span class="cov0" title="0">return "{" + strings.Join(pairs, ", ") + "}"</span>
}

// Boolean representa un objeto boolean

// Boolean representa un objeto boolean
type Boolean struct {
        Value bool
}

func (b *Boolean) Type() string    <span class="cov0" title="0">{ return "BOOLEAN_OBJ" }</span>
func (b *Boolean) Inspect() string <span class="cov0" title="0">{ return fmt.Sprintf("%t", b.Value) }</span>

// Null representa un objeto null
type Null struct{}

func (n *Null) Type() string    <span class="cov0" title="0">{ return "NULL_OBJ" }</span>
func (n *Null) Inspect() string <span class="cov0" title="0">{ return "null" }</span>

// Value representa un valor en tiempo de ejecución de Zylo
type Value interface{}

// Environment representa el entorno de ejecución con variables
type Environment struct {
        variables map[string]Value
        parent    *Environment
}

// NewEnvironment crea un nuevo entorno
func NewEnvironment() *Environment <span class="cov0" title="0">{
        return &amp;Environment{
                variables: make(map[string]Value),
                parent:    nil,
        }
}</span>

// NewChildEnvironment crea un entorno hijo
func (e *Environment) NewChildEnvironment() *Environment <span class="cov0" title="0">{
        return &amp;Environment{
                variables: make(map[string]Value),
                parent:    e,
        }
}</span>

// Get obtiene el valor de una variable
func (e *Environment) Get(name string) (Value, bool) <span class="cov0" title="0">{
        if value, exists := e.variables[name]; exists </span><span class="cov0" title="0">{
                return value, true
        }</span>
        <span class="cov0" title="0">if e.parent != nil </span><span class="cov0" title="0">{
                return e.parent.Get(name)
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

// Set establece el valor de una variable
func (e *Environment) Set(name string, value Value) <span class="cov0" title="0">{
        e.variables[name] = value
}</span>

// Evaluator evalúa expresiones y sentencias de Zylo
type Evaluator struct {
        env    *Environment
        reader *bufio.Reader
}

// NewEvaluator crea un nuevo evaluador
func NewEvaluator() *Evaluator <span class="cov0" title="0">{
        eval := &amp;Evaluator{
                env:    NewEnvironment(),
                reader: bufio.NewReader(os.Stdin),
        }
        eval.InitBuiltins()
        return eval
}</span>

// InitBuiltins inicializa las funciones incorporadas
func (e *Evaluator) InitBuiltins() <span class="cov0" title="0">{
        // Mostrar por consola
        e.env.Set("show.log", &amp;BuiltinFunction{
                Name: "show.log",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        for _, arg := range args </span><span class="cov0" title="0">{
                                if obj, ok := arg.(ZyloObject); ok </span><span class="cov0" title="0">{
                                        fmt.Print(obj.Inspect(), " ")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Print(arg, " ")
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()
                        os.Stdout.Sync() // Force flush after printing
                        return &amp;Null{}, nil</span>
                },
        })

        // Leer una línea como string
        <span class="cov0" title="0">e.env.Set("read.line", &amp;BuiltinFunction{
                Name: "read.line",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        fmt.Print("&gt; ")  // Mostrar prompt
                        os.Stdout.Sync() // Force flush
                        input, err := e.reader.ReadString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("⚠️  No se pudo leer entrada, usando valor vacío")
                                return &amp;String{Value: ""}, nil
                        }</span>
                        <span class="cov0" title="0">return &amp;String{Value: strings.TrimSpace(input)}, nil</span>
                },
        })

        // Leer un número entero
        <span class="cov0" title="0">e.env.Set("read.int", &amp;BuiltinFunction{
                Name: "read.int",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        for </span><span class="cov0" title="0">{ // Loop until valid input is received
                                fmt.Print("&gt; ")  // Mostrar prompt
                                os.Stdout.Sync() // Force flush
                                input, err := e.reader.ReadString('\n')
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("⚠️  No se pudo leer entrada, usando 0 por defecto")
                                        return &amp;Integer{Value: 0}, nil // Still return 0 on read error, as per original logic
                                }</span>
                                <span class="cov0" title="0">input = strings.TrimSpace(input)
                                n, err := strconv.Atoi(input)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Println("❌ Error: no es un número válido, por favor intenta de nuevo.")
                                        // Continue the loop to re-prompt
                                }</span> else<span class="cov0" title="0"> {
                                        // Valid input received, return the integer
                                        return &amp;Integer{Value: int64(n)}, nil
                                }</span>
                        }
                },
        })

        // Convertir número a string
        <span class="cov0" title="0">e.env.Set("string", &amp;BuiltinFunction{
                Name: "string",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("string() espera exactamente 1 argumento, recibió %d", len(args))
                        }</span>

                        <span class="cov0" title="0">switch arg := args[0].(type) </span>{
                        case *Integer:<span class="cov0" title="0">
                                return &amp;String{Value: fmt.Sprintf("%d", arg.Value)}, nil</span>
                        case *Float:<span class="cov0" title="0">
                                return &amp;String{Value: fmt.Sprintf("%g", arg.Value)}, nil</span>
                        case *String:<span class="cov0" title="0">
                                return arg, nil</span>
                        case *Boolean:<span class="cov0" title="0">
                                return &amp;String{Value: fmt.Sprintf("%t", arg.Value)}, nil</span>
                        default:<span class="cov0" title="0">
                                return &amp;String{Value: fmt.Sprintf("%v", arg)}, nil</span>
                        }
                },
        })

        // len function
        <span class="cov0" title="0">e.env.Set("len", &amp;BuiltinFunction{
                Name: "len",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("len() expects exactly 1 argument")
                        }</span>
                        <span class="cov0" title="0">switch arg := args[0].(type) </span>{
                        case *List:<span class="cov0" title="0">
                                return &amp;Integer{Value: int64(len(arg.Items))}, nil</span>
                        case *String:<span class="cov0" title="0">
                                return &amp;Integer{Value: int64(len(arg.Value))}, nil</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("len() not supported for %T", arg)</span>
                        }
                },
        })

        // split function
        <span class="cov0" title="0">e.env.Set("split", &amp;BuiltinFunction{
                Name: "split",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("split() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">str, ok := args[0].(*String)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("first argument to split() must be string")
                        }</span>
                        <span class="cov0" title="0">sep, ok := args[1].(*String)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("second argument to split() must be string")
                        }</span>
                        <span class="cov0" title="0">parts := strings.Split(str.Value, sep.Value)
                        items := make([]Value, len(parts))
                        for i, part := range parts </span><span class="cov0" title="0">{
                                items[i] = &amp;String{Value: part}
                        }</span>
                        <span class="cov0" title="0">return &amp;List{Items: items}, nil</span>
                },
        })

        // to_number function
        <span class="cov0" title="0">e.env.Set("to_number", &amp;BuiltinFunction{
                Name: "to_number",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("to_number() expects exactly 1 argument")
                        }</span>
                        <span class="cov0" title="0">str, ok := args[0].(*String)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("argument to to_number() must be string")
                        }</span>
                        <span class="cov0" title="0">if val, err := strconv.ParseFloat(str.Value, 64); err == nil </span><span class="cov0" title="0">{
                                return &amp;Float{Value: val}, nil
                        }</span>
                        <span class="cov0" title="0">if val, err := strconv.Atoi(str.Value); err == nil </span><span class="cov0" title="0">{
                                return &amp;Integer{Value: int64(val)}, nil
                        }</span>
                        <span class="cov0" title="0">return &amp;Null{}, nil</span>
                },
        })

        // zyloruntime.Split function
        <span class="cov0" title="0">e.env.Set("zyloruntime.Split", &amp;BuiltinFunction{
                Name: "zyloruntime.Split",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("zyloruntime.Split() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">str, ok := args[0].(*String)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("first argument to zyloruntime.Split() must be string")
                        }</span>
                        <span class="cov0" title="0">sep, ok := args[1].(*String)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("second argument to zyloruntime.Split() must be string")
                        }</span>
                        <span class="cov0" title="0">parts := strings.Split(str.Value, sep.Value)
                        items := make([]Value, len(parts))
                        for i, part := range parts </span><span class="cov0" title="0">{
                                items[i] = &amp;String{Value: part}
                        }</span>
                        <span class="cov0" title="0">return &amp;List{Items: items}, nil</span>
                },
        })

        // try function
        <span class="cov0" title="0">e.env.Set("try", &amp;BuiltinFunction{
                Name: "try",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("try() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">funcBlock, ok := args[0].(*ZyloFunction)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("first argument to try() must be function")
                        }</span>
                        <span class="cov0" title="0">catchBlock, ok := args[1].(*ZyloFunction)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("second argument to try() must be function")
                        }</span>
                        // Call funcBlock
                        <span class="cov0" title="0">result, err := e.callZyloFunction(funcBlock, []Value{})
                        if err != nil </span><span class="cov0" title="0">{
                                // Call catchBlock with error as string
                                errorStr := &amp;String{Value: err.Error()}
                                _, catchErr := e.callZyloFunction(catchBlock, []Value{errorStr})
                                if catchErr != nil </span><span class="cov0" title="0">{
                                        return nil, catchErr
                                }</span>
                                <span class="cov0" title="0">return &amp;Null{}, nil</span>
                        }
                        <span class="cov0" title="0">return result, nil</span>
                },
        })

        // zyloruntime namespace (dummy object)
        <span class="cov0" title="0">e.env.Set("zyloruntime", &amp;String{Value: "zyloruntime_namespace"})

        // getInput function
        e.env.Set("getInput", &amp;BuiltinFunction{
                Name: "getInput",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        fmt.Print("&gt; ")
                        os.Stdout.Sync()
                        input, err := e.reader.ReadString('\n')
                        if err != nil </span><span class="cov0" title="0">{
                                return &amp;String{Value: ""}, nil
                        }</span>
                        <span class="cov0" title="0">return &amp;String{Value: strings.TrimSpace(input)}, nil</span>
                },
        })

        // null value
        <span class="cov0" title="0">e.env.Set("null", &amp;Null{})

        // Math functions for calculator
        e.env.Set("add", &amp;BuiltinFunction{
                Name: "add",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("add() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">return e.applyOperator("+", args[0], args[1])</span>
                },
        })

        <span class="cov0" title="0">e.env.Set("subtract", &amp;BuiltinFunction{
                Name: "subtract",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("subtract() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">return e.applyOperator("-", args[0], args[1])</span>
                },
        })

        <span class="cov0" title="0">e.env.Set("multiply", &amp;BuiltinFunction{
                Name: "multiply",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("multiply() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">return e.applyOperator("*", args[0], args[1])</span>
                },
        })

        <span class="cov0" title="0">e.env.Set("divide", &amp;BuiltinFunction{
                Name: "divide",
                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("divide() expects exactly 2 arguments")
                        }</span>
                        <span class="cov0" title="0">return e.applyOperator("/", args[0], args[1])</span>
                },
        })
}

// EvaluateProgram evalúa un programa completo
func (e *Evaluator) EvaluateProgram(program *ast.Program) error <span class="cov0" title="0">{
        for _, stmt := range program.Statements </span><span class="cov0" title="0">{
                _, err := e.evaluateStatement(stmt)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Execute main function if it exists
        <span class="cov0" title="0">mainFunc, exists := e.env.Get("main")
        if exists </span><span class="cov0" title="0">{
                if fn, ok := mainFunc.(*ZyloFunction); ok </span><span class="cov0" title="0">{
                        _, err := e.callZyloFunction(fn, []Value{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// evaluateStatement evalúa una sentencia
func (e *Evaluator) evaluateStatement(stmt ast.Statement) (Value, error) <span class="cov0" title="0">{
        if stmt == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil statement")
        }</span>
        <span class="cov0" title="0">switch s := stmt.(type) </span>{
        case *ast.VarStatement:<span class="cov0" title="0">
                if s == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil var statement")
                }</span>
                <span class="cov0" title="0">err := e.evaluateVarStatement(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;Null{}, nil</span> // Var statements don't return a value
        case *ast.ExpressionStatement:<span class="cov0" title="0">
                if s == nil </span><span class="cov0" title="0">{
                        return &amp;Null{}, nil // Skip nil expression statements
                }</span>
                <span class="cov0" title="0">if s.Expression == nil </span><span class="cov0" title="0">{
                        return &amp;Null{}, nil // Skip statements with nil expressions
                }</span>
                <span class="cov0" title="0">return e.evaluateExpression(s.Expression)</span>
        case *ast.FuncStatement:<span class="cov0" title="0">
                if s == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil func statement")
                }</span>
                <span class="cov0" title="0">err := e.evaluateFuncStatement(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;Null{}, nil</span> // Func statements don't return a value
        case *ast.ReturnStatement:<span class="cov0" title="0">
                if s == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil return statement")
                }</span>
                // If a return statement is encountered directly, evaluate its value and return it.
                // This assumes it's handled correctly by the caller (e.g., evaluateBlockStatement).
                <span class="cov0" title="0">if s.ReturnValue != nil </span><span class="cov0" title="0">{
                        return e.evaluateExpression(s.ReturnValue)
                }</span>
                <span class="cov0" title="0">return &amp;Null{}, nil</span> // Return Null if return statement has no value
        case *ast.IfStatement:<span class="cov0" title="0">
                if s == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil if statement")
                }</span>
                <span class="cov0" title="0">return e.evaluateIfStatement(s)</span> // This already returns Value, error (after the fix)
        case *ast.WhileStatement:<span class="cov0" title="0">
                if s == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil while statement")
                }</span>
                <span class="cov0" title="0">return e.evaluateWhileStatement(s)</span>
        case *ast.ForInStatement:<span class="cov0" title="0">
                return e.evaluateForInStatement(s)</span>
        case *ast.BreakStatement:<span class="cov0" title="0">
                return e.evaluateBreakStatement(s)</span>
        case *ast.ContinueStatement:<span class="cov0" title="0">
                return e.evaluateContinueStatement(s)</span>
        case *ast.ClassStatement:<span class="cov0" title="0">
                return e.evaluateClassStatement(s)</span>
        case *ast.TryStatement:<span class="cov0" title="0">
                // TODO: Implement try-catch to return Value, error
                return e.evaluateTryStatement(s)</span> // Assuming this will be fixed to return Value, error
        case *ast.ThrowStatement:<span class="cov0" title="0">
                // TODO: Implement throw to return Value, error
                return e.evaluateThrowStatement(s)</span> // Assuming this will be fixed to return Value, error
        case *ast.ImportStatement:<span class="cov0" title="0">
                return e.evaluateImportStatement(s)</span>
        case *ast.BlockStatement:<span class="cov0" title="0">
                return e.evaluateBlockStatement(s)</span> // This needs to return Value, error
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("sentencia no soportada: %T", s)</span>
        }
}

// evaluateVarStatement evalúa una declaración de variable
func (e *Evaluator) evaluateVarStatement(stmt *ast.VarStatement) error <span class="cov0" title="0">{
        var value Value
        var err error
        if stmt.Value != nil </span><span class="cov0" title="0">{
                value, err = e.evaluateExpression(stmt.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                value = &amp;Null{}
        }</span>
        <span class="cov0" title="0">e.env.Set(stmt.Name.Value, value)
        return nil</span>
}

// evaluateFuncStatement evalúa una declaración de función
func (e *Evaluator) evaluateFuncStatement(stmt *ast.FuncStatement) error <span class="cov0" title="0">{
        // Crear una función Zylo
        zyloFunc := &amp;ZyloFunction{
                Name:       stmt.Name.Value,
                Parameters: stmt.Parameters,
                Body:       stmt.Body,
                Env:        e.env,
        }
        e.env.Set(stmt.Name.Value, zyloFunc)
        return nil
}</span>

// evaluateIfStatement evalúa una sentencia if
func (e *Evaluator) evaluateIfStatement(stmt *ast.IfStatement) (Value, error) <span class="cov0" title="0">{
        condition, err := e.evaluateExpression(stmt.Condition)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if e.isTruthy(condition) </span><span class="cov0" title="0">{
                // Evaluar el bloque 'consequence' (el 'if' principal)
                return e.evaluateBlockStatement(stmt.Consequence)
        }</span> else<span class="cov0" title="0"> if stmt.Alternative != nil </span><span class="cov0" title="0">{
                // Si la condición principal es falsa, verificar el tipo de la alternativa.
                // Based on the compiler error, stmt.Alternative is likely always a *ast.BlockStatement.
                // The original code had a switch that handled both *ast.BlockStatement and *ast.IfStatement.
                // The error message suggests *ast.BlockStatement is not an interface, implying stmt.Alternative
                // is a concrete type. If it's always *ast.BlockStatement, then we only need to handle that.

                // Since Alternative is always *ast.BlockStatement or nil, we can directly call evaluateBlockStatement
                return e.evaluateBlockStatement(stmt.Alternative)
        }</span>

        // Si ninguna condición se cumple y no hay alternativa, no hacer nada.
        <span class="cov0" title="0">return &amp;Null{}, nil</span>
}

// evaluateTryStatement evalúa una sentencia try-catch
func (e *Evaluator) evaluateTryStatement(stmt *ast.TryStatement) (Value, error) <span class="cov0" title="0">{
        // TODO: Implementar try-catch
        if stmt.TryBlock == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil try block")
        }</span>
        <span class="cov0" title="0">return e.evaluateBlockStatement(stmt.TryBlock)</span>
}

// evaluateThrowStatement evalúa una sentencia throw
func (e *Evaluator) evaluateThrowStatement(stmt *ast.ThrowStatement) (Value, error) <span class="cov0" title="0">{
        // TODO: Implementar throw
        return &amp;Null{}, nil
}</span>

// evaluateBlockStatement evalúa un bloque de sentencias
func (e *Evaluator) evaluateBlockStatement(stmt *ast.BlockStatement) (Value, error) <span class="cov0" title="0">{
        // Create a new environment for this block to isolate variable scope
        childEnv := e.env.NewChildEnvironment()
        oldEnv := e.env
        e.env = childEnv
        defer func() </span><span class="cov0" title="0">{ e.env = oldEnv }</span>()

        <span class="cov0" title="0">var lastValue Value = &amp;Null{} // To store the value of the last expression

        for _, bodyStmt := range stmt.Statements </span><span class="cov0" title="0">{
                // Evaluate statement and capture its value
                value, err := e.evaluateStatement(bodyStmt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err // Propagate error
                }</span>

                // Handle break and continue
                <span class="cov0" title="0">if _, ok := value.(*BreakValue); ok </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
                <span class="cov0" title="0">if _, ok := value.(*ContinueValue); ok </span><span class="cov0" title="0">{
                        return value, nil
                }</span>

                // Capture the value for potential return
                <span class="cov0" title="0">lastValue = value</span>
        }

        // Return the value of the last evaluated statement
        <span class="cov0" title="0">return lastValue, nil</span>
}

// evaluateWhileStatement evalúa una sentencia while
func (e *Evaluator) evaluateWhileStatement(stmt *ast.WhileStatement) (Value, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                condition, err := e.evaluateExpression(stmt.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if !e.isTruthy(condition) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Evaluate body statements directly without creating child environment
                <span class="cov0" title="0">for _, bodyStmt := range stmt.Body.Statements </span><span class="cov0" title="0">{
                        value, err := e.evaluateStatement(bodyStmt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Handle break and continue
                        <span class="cov0" title="0">if _, ok := value.(*BreakValue); ok </span><span class="cov0" title="0">{
                                return &amp;Null{}, nil // Break out of while
                        }</span>
                        <span class="cov0" title="0">if _, ok := value.(*ContinueValue); ok </span><span class="cov0" title="0">{
                                break</span> // Continue to next iteration
                        }
                }
        }

        <span class="cov0" title="0">return &amp;Null{}, nil</span>
}

// evaluateForInStatement evalúa una sentencia for in
func (e *Evaluator) evaluateForInStatement(stmt *ast.ForInStatement) (Value, error) <span class="cov0" title="0">{
        iterable, err := e.evaluateExpression(stmt.Iterable)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch iter := iterable.(type) </span>{
        case *List:<span class="cov0" title="0">
                for _, element := range iter.Items </span><span class="cov0" title="0">{
                        e.env.Set(stmt.Identifier.Value, element)

                        result, err := e.evaluateBlockStatement(stmt.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Handle break and continue
                        <span class="cov0" title="0">if _, ok := result.(*BreakValue); ok </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if _, ok := result.(*ContinueValue); ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
        case *String:<span class="cov0" title="0">
                for _, char := range iter.Value </span><span class="cov0" title="0">{
                        e.env.Set(stmt.Identifier.Value, &amp;String{Value: string(char)})

                        result, err := e.evaluateBlockStatement(stmt.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Handle break and continue
                        <span class="cov0" title="0">if _, ok := result.(*BreakValue); ok </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if _, ok := result.(*ContinueValue); ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot iterate over %T", iterable)</span>
        }

        <span class="cov0" title="0">return &amp;Null{}, nil</span>
}

// evaluateImportStatement evalúa una declaración de import
func (e *Evaluator) evaluateImportStatement(stmt *ast.ImportStatement) (Value, error) <span class="cov0" title="0">{
        if stmt.ModuleName == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("import statement has nil module name")
        }</span>

        <span class="cov0" title="0">moduleName := stmt.ModuleName.Value

        // Check if module is already imported - if so, ignore silently
        if _, exists := e.env.Get(moduleName); exists </span><span class="cov0" title="0">{
                return &amp;Null{}, nil
        }</span>

        // For now, we only support "zyloruntime" module
        <span class="cov0" title="0">if moduleName == "zyloruntime" </span><span class="cov0" title="0">{
                // Create a module object with available functions
                moduleObj := &amp;String{Value: "zyloruntime_module"}
                e.env.Set(moduleName, moduleObj)
                return &amp;Null{}, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("Module '%s' not found", moduleName)</span>
}

// evaluateBreakStatement evalúa una sentencia break
func (e *Evaluator) evaluateBreakStatement(stmt *ast.BreakStatement) (Value, error) <span class="cov0" title="0">{
        return &amp;BreakValue{}, nil
}</span>

// evaluateContinueStatement evalúa una sentencia continue
func (e *Evaluator) evaluateContinueStatement(stmt *ast.ContinueStatement) (Value, error) <span class="cov0" title="0">{
        return &amp;ContinueValue{}, nil
}</span>

// evaluateClassStatement evalúa una declaración de clase
func (e *Evaluator) evaluateClassStatement(stmt *ast.ClassStatement) (Value, error) <span class="cov0" title="0">{
        // Create a class object
        classObj := &amp;ZyloClass{
                Name:       stmt.Name.Value,
                Attributes: make(map[string]Value),
                Methods:    make(map[string]*ZyloFunction),
                InitMethod: nil,
        }

        // Set attributes
        for _, attr := range stmt.Attributes </span><span class="cov0" title="0">{
                if attr.Value != nil </span><span class="cov0" title="0">{
                        value, err := e.evaluateExpression(attr.Value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">classObj.Attributes[attr.Name.Value] = value</span>
                } else<span class="cov0" title="0"> {
                        classObj.Attributes[attr.Name.Value] = &amp;Null{}
                }</span>
        }

        // Set methods
        <span class="cov0" title="0">for _, method := range stmt.Methods </span><span class="cov0" title="0">{
                zyloFunc := &amp;ZyloFunction{
                        Name:       method.Name.Value,
                        Parameters: method.Parameters,
                        Body:       method.Body,
                        Env:        e.env,
                }
                classObj.Methods[method.Name.Value] = zyloFunc

                // Check if it's the init method
                if method.Name.Value == "init" </span><span class="cov0" title="0">{
                        classObj.InitMethod = zyloFunc
                }</span>
        }

        <span class="cov0" title="0">e.env.Set(stmt.Name.Value, classObj)
        return &amp;Null{}, nil</span>
}

// evaluateExpression evalúa una expresión
func (e *Evaluator) evaluateExpression(exp ast.Expression) (Value, error) <span class="cov0" title="0">{
        if exp == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil expression passed to evaluator")
        }</span>

        <span class="cov0" title="0">switch ex := exp.(type) </span>{
        case *ast.Identifier:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil identifier")
                }</span>
                <span class="cov0" title="0">return e.evaluateIdentifier(ex)</span>
        case *ast.StringLiteral:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil string literal")
                }</span>
                <span class="cov0" title="0">return &amp;String{Value: ex.Value}, nil</span>
        case *ast.NumberLiteral:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil number literal")
                }</span>
                <span class="cov0" title="0">if val, ok := ex.Value.(float64); ok </span><span class="cov0" title="0">{
                        return &amp;Float{Value: val}, nil
                }</span> else<span class="cov0" title="0"> if val, ok := ex.Value.(int64); ok </span><span class="cov0" title="0">{
                        return &amp;Integer{Value: val}, nil
                }</span>
                <span class="cov0" title="0">return &amp;Integer{Value: 0}, nil</span>
        case *ast.BooleanLiteral:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil boolean literal")
                }</span>
                <span class="cov0" title="0">return &amp;Boolean{Value: ex.Value}, nil</span>
        case *ast.NullLiteral:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil null literal")
                }</span>
                <span class="cov0" title="0">return &amp;Null{}, nil</span>
        case *ast.CallExpression:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil call expression")
                }</span>
                <span class="cov0" title="0">return e.evaluateCallExpression(ex)</span>
        case *ast.MemberExpression:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil member expression")
                }</span>
                <span class="cov0" title="0">return e.evaluateMemberExpression(ex)</span>
        case *ast.ListLiteral:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil list literal")
                }</span>
                <span class="cov0" title="0">elements := make([]Value, len(ex.Elements))
                for i, el := range ex.Elements </span><span class="cov0" title="0">{
                        var err error
                        elements[i], err = e.evaluateExpression(el)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return &amp;List{Items: elements}, nil</span>
        case *ast.HashLiteral:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil hash literal")
                }</span>
                <span class="cov0" title="0">pairs := make(map[string]Value)
                for key, value := range ex.Pairs </span><span class="cov0" title="0">{
                        keyVal, err := e.evaluateExpression(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        // For now, assume keys are strings
                        <span class="cov0" title="0">keyStr, ok := keyVal.(*String)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("hash key must be string")
                        }</span>
                        <span class="cov0" title="0">val, err := e.evaluateExpression(value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">pairs[keyStr.Value] = val</span>
                }
                <span class="cov0" title="0">return &amp;Hash{Pairs: pairs}, nil</span>
        case *ast.IndexExpression:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil index expression")
                }</span>
                <span class="cov0" title="0">left, err := e.evaluateExpression(ex.Left)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">index, err := e.evaluateExpression(ex.Index)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return e.indexValue(left, index)</span>
        case *ast.InfixExpression:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil infix expression")
                }</span>
                <span class="cov0" title="0">return e.evaluateInfixExpression(ex)</span>
        case *ast.PrefixExpression:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil prefix expression")
                }</span>
                <span class="cov0" title="0">return e.evaluatePrefixExpression(ex)</span>
        case *ast.ThisExpression:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil this expression")
                }</span>
                <span class="cov0" title="0">return e.evaluateThisExpression(ex)</span>
        case *ast.ImportStatement:<span class="cov0" title="0">
                if ex == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil import statement")
                }</span>
                <span class="cov0" title="0">return e.evaluateImportStatement(ex)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expresión no soportada: %T", ex)</span>
        }
}

// evaluateIdentifier evalúa un identificador
func (e *Evaluator) evaluateIdentifier(exp *ast.Identifier) (Value, error) <span class="cov0" title="0">{
        value, exists := e.env.Get(exp.Value)
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("variable no definida: %s", exp.Value)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// evaluateMemberExpression evalúa una expresión de acceso a miembro
func (e *Evaluator) evaluateMemberExpression(exp *ast.MemberExpression) (Value, error) <span class="cov0" title="0">{
        if exp.Object == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil object in member expression")
        }</span>
        <span class="cov0" title="0">if exp.Property == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil property in member expression")
        }</span>

        // Obtener el nombre de la propiedad/método
        <span class="cov0" title="0">propName := exp.Property.Value

        // Manejar casos específicos como 'show.log' y 'read.line' sin evaluar el objeto primero
        if identifier, ok := exp.Object.(*ast.Identifier); ok </span><span class="cov0" title="0">{
                objName := identifier.Value

                // Crear el nombre completo de la función built-in
                fullName := objName + "." + propName

                // Buscar en el entorno si existe una función built-in
                if builtin, exists := e.env.Get(fullName); exists </span><span class="cov0" title="0">{
                        return builtin, nil
                }</span>
        }

        // Para otros casos, evaluar el objeto primero
                <span class="cov0" title="0">obj, err := e.evaluateExpression(exp.Object)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if obj == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot access member on nil object")
                }</span>

        // Handle zyloruntime namespace
        <span class="cov0" title="0">if identifier, ok := obj.(*ast.Identifier); ok &amp;&amp; identifier.Value == "zyloruntime" </span><span class="cov0" title="0">{
                switch propName </span>{
                case "Split":<span class="cov0" title="0">
                        return &amp;BuiltinFunction{
                                Name: "zyloruntime.Split",
                                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                                        if len(args) != 2 </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("zyloruntime.Split() expects exactly 2 arguments")
                                        }</span>
                                        <span class="cov0" title="0">str, ok := args[0].(*String)
                                        if !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("first argument to zyloruntime.Split() must be string")
                                        }</span>
                                        <span class="cov0" title="0">sep, ok := args[1].(*String)
                                        if !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("second argument to zyloruntime.Split() must be string")
                                        }</span>
                                        <span class="cov0" title="0">parts := strings.Split(str.Value, sep.Value)
                                        items := make([]Value, len(parts))
                                        for i, part := range parts </span><span class="cov0" title="0">{
                                                items[i] = &amp;String{Value: part}
                                        }</span>
                                        <span class="cov0" title="0">return &amp;List{Items: items}, nil</span>
                                },
                        }, nil
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("property '%s' not found on zyloruntime", propName)</span>
                }
        }

        // Handle List methods
        <span class="cov0" title="0">if list, ok := obj.(*List); ok </span><span class="cov0" title="0">{
                switch propName </span>{
                case "Get":<span class="cov0" title="0">
                        return &amp;BuiltinFunction{
                                Name: "List.Get",
                                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                                        if len(args) != 1 </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("List.Get() expects exactly 1 argument")
                                        }</span>
                                        <span class="cov0" title="0">idx, ok := args[0].(*Integer)
                                        if !ok </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("List.Get() index must be integer")
                                        }</span>
                                        <span class="cov0" title="0">if idx.Value &lt; 0 || int(idx.Value) &gt;= len(list.Items) </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("index out of bounds")
                                        }</span>
                                        <span class="cov0" title="0">return list.Items[idx.Value], nil</span>
                                },
                        }, nil
                case "Append":<span class="cov0" title="0">
                        return &amp;BuiltinFunction{
                                Name: "List.Append",
                                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                                        if len(args) != 1 </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("List.Append() expects exactly 1 argument")
                                        }</span>
                                        <span class="cov0" title="0">list.Items = append(list.Items, args[0])
                                        return &amp;Null{}, nil</span>
                                },
                        }, nil
                case "Len":<span class="cov0" title="0">
                        return &amp;BuiltinFunction{
                                Name: "List.Len",
                                Fn: func(args []Value) (Value, error) </span><span class="cov0" title="0">{
                                        return &amp;Integer{Value: int64(len(list.Items))}, nil
                                }</span>,
                        }, nil
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("method '%s' not found on List", propName)</span>
                }
        }

        // Handle instance member access
        <span class="cov0" title="0">if instance, ok := obj.(*ZyloInstance); ok </span><span class="cov0" title="0">{
                if field, exists := instance.Fields[propName]; exists </span><span class="cov0" title="0">{
                        return field, nil
                }</span>
                <span class="cov0" title="0">if method, exists := instance.Class.Methods[propName]; exists </span><span class="cov0" title="0">{
                        // Return a bound method
                        return &amp;BoundMethod{
                                Instance: instance,
                                Method:   method,
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("property '%s' not found on instance of %s", propName, instance.Class.Name)</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("cannot access property '%s' on %T", propName, obj)</span>
}

// evaluateCallExpression evalúa una llamada a función
func (e *Evaluator) evaluateCallExpression(exp *ast.CallExpression) (Value, error) <span class="cov0" title="0">{
        if exp.Function == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil function in call expression")
        }</span>

        // Evaluar la función
        <span class="cov0" title="0">fn, err := e.evaluateExpression(exp.Function)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if it's a class instantiation
        <span class="cov0" title="0">if class, ok := fn.(*ZyloClass); ok </span><span class="cov0" title="0">{
                return e.instantiateClass(class, exp.Arguments)
        }</span>

        // Evaluar argumentos
        <span class="cov0" title="0">args := make([]Value, len(exp.Arguments))
        for i, arg := range exp.Arguments </span><span class="cov0" title="0">{
                if arg == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("nil argument at position %d in call expression", i)
                }</span>
                <span class="cov0" title="0">args[i], err = e.evaluateExpression(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Llamar a la función
        <span class="cov0" title="0">return e.callFunction(fn, args)</span>
}

// evaluateInfixExpression evalúa una expresión infija
func (e *Evaluator) evaluateInfixExpression(exp *ast.InfixExpression) (Value, error) <span class="cov0" title="0">{
        if exp.Left == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil left operand in infix expression")
        }</span>
        <span class="cov0" title="0">if exp.Right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil right operand in infix expression")
        }</span>

        // Handle assignment operator
        <span class="cov0" title="0">if exp.Operator == "=" </span><span class="cov0" title="0">{
                // Check if left is an identifier
                leftIdent, ok := exp.Left.(*ast.Identifier)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("left side of assignment must be an identifier")
                }</span>

                // Evaluate the right side
                <span class="cov0" title="0">right, err := e.evaluateExpression(exp.Right)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Check if the variable is declared (exists in environment)
                <span class="cov0" title="0">_, exists := e.env.Get(leftIdent.Value)
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("variable no definida: %s", leftIdent.Value)
                }</span>

                // Assign the value
                <span class="cov0" title="0">e.env.Set(leftIdent.Value, right)
                return right, nil</span>
        }

        <span class="cov0" title="0">left, err := e.evaluateExpression(exp.Left)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateExpression(exp.Right)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return e.applyOperator(exp.Operator, left, right)</span>
}

// evaluatePrefixExpression evalúa una expresión prefija
func (e *Evaluator) evaluatePrefixExpression(exp *ast.PrefixExpression) (Value, error) <span class="cov0" title="0">{
        if exp.Right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nil right operand in prefix expression")
        }</span>

        <span class="cov0" title="0">right, err := e.evaluateExpression(exp.Right)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch exp.Operator </span>{
        case "!":<span class="cov0" title="0">
                return &amp;Boolean{Value: !e.isTruthy(right)}, nil</span>
        case "-":<span class="cov0" title="0">
                if num, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                        return &amp;Integer{Value: -num.Value}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("operador '-' no soportado para tipo %T", right)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("operador prefijo no soportado: %s", exp.Operator)</span>
        }
}

// callFunction llama a una función
func (e *Evaluator) callFunction(fn Value, args []Value) (Value, error) <span class="cov0" title="0">{
        if fn == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot call nil function")
        }</span>
        <span class="cov0" title="0">switch f := fn.(type) </span>{
        case *ZyloFunction:<span class="cov0" title="0">
                return e.callZyloFunction(f, args)</span>
        case *BuiltinFunction:<span class="cov0" title="0">
                return f.Fn(args)</span>
        case *BoundMethod:<span class="cov0" title="0">
                return e.callBoundMethod(f, args)</span>
        default:<span class="cov0" title="0">
                // Intentar funciones built-in
                if ident, ok := fn.(*ast.Identifier); ok </span><span class="cov0" title="0">{
                        return e.callBuiltinFunction(ident.Value, args)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("no se puede llamar a: %T", fn)</span>
        }
}

// instantiateClass crea una instancia de una clase
func (e *Evaluator) instantiateClass(class *ZyloClass, args []ast.Expression) (Value, error) <span class="cov0" title="0">{
        instance := &amp;ZyloInstance{
                Class:  class,
                Fields: make(map[string]Value),
        }

        // Copy class attributes to instance
        for name, value := range class.Attributes </span><span class="cov0" title="0">{
                instance.Fields[name] = value
        }</span>

        // Call init method if it exists
        <span class="cov0" title="0">if class.InitMethod != nil </span><span class="cov0" title="0">{
                // Evaluate arguments
                evalArgs := make([]Value, len(args))
                for i, arg := range args </span><span class="cov0" title="0">{
                        var err error
                        evalArgs[i], err = e.evaluateExpression(arg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // Create instance environment
                <span class="cov0" title="0">funcEnv := class.InitMethod.Env.NewChildEnvironment()
                funcEnv.Set("this", instance)

                // Set parameters
                for i, param := range class.InitMethod.Parameters </span><span class="cov0" title="0">{
                        if i &lt; len(evalArgs) </span><span class="cov0" title="0">{
                                funcEnv.Set(param.Value, evalArgs[i])
                        }</span>
                }

                // Execute init method
                <span class="cov0" title="0">oldEnv := e.env
                e.env = funcEnv
                defer func() </span><span class="cov0" title="0">{ e.env = oldEnv }</span>()

                <span class="cov0" title="0">_, err := e.evaluateBlockStatement(class.InitMethod.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return instance, nil</span>
}

// callZyloFunction llama a una función Zylo
func (e *Evaluator) callZyloFunction(fn *ZyloFunction, args []Value) (Value, error) <span class="cov0" title="0">{
        // Crear entorno de función
        funcEnv := fn.Env.NewChildEnvironment()

        // Establecer parámetros
        for i, param := range fn.Parameters </span><span class="cov0" title="0">{
                if i &lt; len(args) </span><span class="cov0" title="0">{
                        funcEnv.Set(param.Value, args[i]) // Usar param.Value
                }</span>
        }

        // Ejecutar cuerpo de la función
        <span class="cov0" title="0">oldEnv := e.env
        e.env = funcEnv
        defer func() </span><span class="cov0" title="0">{ e.env = oldEnv }</span>()

        <span class="cov0" title="0">result, err := e.evaluateBlockStatement(fn.Body) // Capture the result
        if err != nil </span><span class="cov0" title="0">{
                return nil, err // Propagate error
        }</span>
        <span class="cov0" title="0">return result, nil</span> // Return the captured result
}

// callBoundMethod llama a un método ligado
func (e *Evaluator) callBoundMethod(boundMethod *BoundMethod, args []Value) (Value, error) <span class="cov0" title="0">{
        // Crear entorno de método
        funcEnv := boundMethod.Method.Env.NewChildEnvironment()
        funcEnv.Set("this", boundMethod.Instance)

        // Establecer parámetros
        for i, param := range boundMethod.Method.Parameters </span><span class="cov0" title="0">{
                if i &lt; len(args) </span><span class="cov0" title="0">{
                        funcEnv.Set(param.Value, args[i])
                }</span>
        }

        // Ejecutar cuerpo del método
        <span class="cov0" title="0">oldEnv := e.env
        e.env = funcEnv
        defer func() </span><span class="cov0" title="0">{ e.env = oldEnv }</span>()

        <span class="cov0" title="0">result, err := e.evaluateBlockStatement(boundMethod.Method.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// evaluateThisExpression evalúa una expresión 'this'
func (e *Evaluator) evaluateThisExpression(exp *ast.ThisExpression) (Value, error) <span class="cov0" title="0">{
        // Buscar 'this' en el entorno actual
        value, exists := e.env.Get("this")
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'this' is not available in this context")
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// callBuiltinFunction llama a una función built-in
func (e *Evaluator) callBuiltinFunction(name string, args []Value) (Value, error) <span class="cov0" title="0">{
        // Buscar la función en el entorno
        if builtin, exists := e.env.Get(name); exists </span><span class="cov0" title="0">{
                if fn, ok := builtin.(*BuiltinFunction); ok </span><span class="cov0" title="0">{
                        return fn.Fn(args)
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("función no definida: %s", name)</span>
}

// applyOperator aplica un operador binario
func (e *Evaluator) applyOperator(operator string, left, right Value) (Value, error) <span class="cov0" title="0">{
        // Check for nil operands
        if left == nil || right == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot apply operator '%s' to nil values", operator)
        }</span>

        <span class="cov0" title="0">switch operator </span>{
        case "+":<span class="cov0" title="0">
                // Manejar concatenación de strings
                if leftStr, ok := left.(*String); ok </span><span class="cov0" title="0">{
                        if rightStr, ok := right.(*String); ok </span><span class="cov0" title="0">{
                                return &amp;String{Value: leftStr.Value + rightStr.Value}, nil
                        }</span>
                        // Convertir números a string para concatenación
                        <span class="cov0" title="0">if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;String{Value: leftStr.Value + fmt.Sprintf("%d", rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;String{Value: leftStr.Value + fmt.Sprintf("%g", rightFloat.Value)}, nil
                        }</span>
                }
                // Manejar concatenación string + número (orden inverso)
                <span class="cov0" title="0">if rightStr, ok := right.(*String); ok </span><span class="cov0" title="0">{
                        if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;String{Value: fmt.Sprintf("%d", leftNum.Value) + rightStr.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;String{Value: fmt.Sprintf("%g", leftFloat.Value) + rightStr.Value}, nil
                        }</span>
                }
                // Operaciones numéricas
                <span class="cov0" title="0">if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Integer{Value: leftNum.Value + rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: float64(leftNum.Value) + rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: leftFloat.Value + float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: leftFloat.Value + rightFloat.Value}, nil
                        }</span>
                }
        case "-":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Integer{Value: leftNum.Value - rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: float64(leftNum.Value) - rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: leftFloat.Value - float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: leftFloat.Value - rightFloat.Value}, nil
                        }</span>
                }
        case "*":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Integer{Value: leftNum.Value * rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: float64(leftNum.Value) * rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: leftFloat.Value * float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Float{Value: leftFloat.Value * rightFloat.Value}, nil
                        }</span>
                }
        case "/":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                if rightNum.Value == 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("división por cero")
                                }</span>
                                <span class="cov0" title="0">return &amp;Integer{Value: leftNum.Value / rightNum.Value}, nil</span>
                        }
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                if rightFloat.Value == 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("división por cero")
                                }</span>
                                <span class="cov0" title="0">return &amp;Float{Value: float64(leftNum.Value) / rightFloat.Value}, nil</span>
                        }
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                if rightNum.Value == 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("división por cero")
                                }</span>
                                <span class="cov0" title="0">return &amp;Float{Value: leftFloat.Value / float64(rightNum.Value)}, nil</span>
                        }
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                if rightFloat.Value == 0 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("división por cero")
                                }</span>
                                <span class="cov0" title="0">return &amp;Float{Value: leftFloat.Value / rightFloat.Value}, nil</span>
                        }
                }
        case "==":<span class="cov0" title="0">
                // Handle string comparison specifically
                if leftStr, ok := left.(*String); ok </span><span class="cov0" title="0">{
                        if rightStr, ok := right.(*String); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftStr.Value == rightStr.Value}, nil
                        }</span>
                }
                // Handle number comparison
                <span class="cov0" title="0">if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftNum.Value == rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: float64(leftNum.Value) == rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value == float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value == rightFloat.Value}, nil
                        }</span>
                }
                // Handle boolean comparison
                <span class="cov0" title="0">if leftBool, ok := left.(*Boolean); ok </span><span class="cov0" title="0">{
                        if rightBool, ok := right.(*Boolean); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftBool.Value == rightBool.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">return &amp;Boolean{Value: false}, nil</span>
        case "!=":<span class="cov0" title="0">
                // Handle string comparison specifically
                if leftStr, ok := left.(*String); ok </span><span class="cov0" title="0">{
                        if rightStr, ok := right.(*String); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftStr.Value != rightStr.Value}, nil
                        }</span>
                }
                // Handle number comparison
                <span class="cov0" title="0">if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftNum.Value != rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: float64(leftNum.Value) != rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value != float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value != rightFloat.Value}, nil
                        }</span>
                }
                // Handle boolean comparison
                <span class="cov0" title="0">if leftBool, ok := left.(*Boolean); ok </span><span class="cov0" title="0">{
                        if rightBool, ok := right.(*Boolean); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftBool.Value != rightBool.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">return &amp;Boolean{Value: true}, nil</span>
        case "&lt;":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftNum.Value &lt; rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: float64(leftNum.Value) &lt; rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &lt; float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &lt; rightFloat.Value}, nil
                        }</span>
                }
        case "&gt;":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftNum.Value &gt; rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: float64(leftNum.Value) &gt; rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &gt; float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &gt; rightFloat.Value}, nil
                        }</span>
                }
        case "&lt;=":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftNum.Value &lt;= rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: float64(leftNum.Value) &lt;= rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &lt;= float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &lt;= rightFloat.Value}, nil
                        }</span>
                }
        case "&gt;=":<span class="cov0" title="0">
                if leftNum, ok := left.(*Integer); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftNum.Value &gt;= rightNum.Value}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: float64(leftNum.Value) &gt;= rightFloat.Value}, nil
                        }</span>
                }
                <span class="cov0" title="0">if leftFloat, ok := left.(*Float); ok </span><span class="cov0" title="0">{
                        if rightNum, ok := right.(*Integer); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &gt;= float64(rightNum.Value)}, nil
                        }</span>
                        <span class="cov0" title="0">if rightFloat, ok := right.(*Float); ok </span><span class="cov0" title="0">{
                                return &amp;Boolean{Value: leftFloat.Value &gt;= rightFloat.Value}, nil
                        }</span>
                }
        case "&amp;&amp;":<span class="cov0" title="0">
                leftBool := e.isTruthy(left)
                if !leftBool </span><span class="cov0" title="0">{
                        return &amp;Boolean{Value: false}, nil
                }</span>
                <span class="cov0" title="0">rightBool := e.isTruthy(right)
                return &amp;Boolean{Value: rightBool}, nil</span>
        case "||":<span class="cov0" title="0">
                leftBool := e.isTruthy(left)
                if leftBool </span><span class="cov0" title="0">{
                        return &amp;Boolean{Value: true}, nil
                }</span>
                <span class="cov0" title="0">rightBool := e.isTruthy(right)
                return &amp;Boolean{Value: rightBool}, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("operador '%s' no soportado para tipos %T y %T", operator, left, right)</span>
}

// isTruthy determina si un valor es "verdadero"
func (e *Evaluator) isTruthy(value Value) bool <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if boolVal, ok := value.(*Boolean); ok </span><span class="cov0" title="0">{
                return boolVal.Value
        }</span>
        <span class="cov0" title="0">if intVal, ok := value.(*Integer); ok </span><span class="cov0" title="0">{
                return intVal.Value != 0
        }</span>
        <span class="cov0" title="0">if strVal, ok := value.(*String); ok </span><span class="cov0" title="0">{
                return len(strVal.Value) &gt; 0
        }</span>
        <span class="cov0" title="0">return true</span>
}

// indexValue handles indexing for arrays and strings
func (e *Evaluator) indexValue(left, index Value) (Value, error) <span class="cov0" title="0">{
        if left == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot index nil value")
        }</span>
        <span class="cov0" title="0">switch l := left.(type) </span>{
        case *List:<span class="cov0" title="0">
                idx, ok := index.(*Integer)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("list index must be integer")
                }</span>
                <span class="cov0" title="0">if idx.Value &lt; 0 || int(idx.Value) &gt;= len(l.Items) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index out of bounds")
                }</span>
                <span class="cov0" title="0">return l.Items[idx.Value], nil</span>
        case *String:<span class="cov0" title="0">
                idx, ok := index.(*Integer)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("string index must be integer")
                }</span>
                <span class="cov0" title="0">if idx.Value &lt; 0 || int(idx.Value) &gt;= len(l.Value) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index out of bounds")
                }</span>
                <span class="cov0" title="0">return &amp;String{Value: string(l.Value[idx.Value])}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot index %T", left)</span>
        }
}

// ZyloFunction representa una función definida en Zylo
type ZyloFunction struct {
        Name       string
        Parameters []*ast.Identifier // Cambiado de []*ast.Variable a []*ast.Identifier
        ReturnType string          // Nuevo campo para el tipo de retorno
        Body       *ast.BlockStatement
        Env        *Environment
}

// BuiltinFunction representa una función built-in
type BuiltinFunction struct {
        Name string
        Fn   func([]Value) (Value, error)
}

// ZyloClass representa una clase definida en Zylo
type ZyloClass struct {
        Name       string
        Attributes map[string]Value
        Methods    map[string]*ZyloFunction
        InitMethod *ZyloFunction
}

func (c *ZyloClass) Type() string <span class="cov0" title="0">{ return "CLASS_OBJ" }</span>
func (c *ZyloClass) Inspect() string <span class="cov0" title="0">{
        return fmt.Sprintf("class %s", c.Name)
}</span>

// ZyloInstance representa una instancia de una clase Zylo
type ZyloInstance struct {
        Class  *ZyloClass
        Fields map[string]Value
}

func (i *ZyloInstance) Type() string <span class="cov0" title="0">{ return "INSTANCE_OBJ" }</span>
func (i *ZyloInstance) Inspect() string <span class="cov0" title="0">{
        return fmt.Sprintf("instance of %s", i.Class.Name)
}</span>

// BoundMethod representa un método ligado a una instancia
type BoundMethod struct {
        Instance *ZyloInstance
        Method   *ZyloFunction
}

func (b *BoundMethod) Type() string <span class="cov0" title="0">{ return "BOUND_METHOD_OBJ" }</span>
func (b *BoundMethod) Inspect() string <span class="cov0" title="0">{
        return fmt.Sprintf("bound method %s", b.Method.Name)
}</span>

// Control flow types for break and continue
type BreakValue struct{}
type ContinueValue struct{}

func (b *BreakValue) Type() string    <span class="cov0" title="0">{ return "BREAK_OBJ" }</span>
func (b *BreakValue) Inspect() string <span class="cov0" title="0">{ return "break" }</span>

func (c *ContinueValue) Type() string    <span class="cov0" title="0">{ return "CONTINUE_OBJ" }</span>
func (c *ContinueValue) Inspect() string <span class="cov0" title="0">{ return "continue" }</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package lexer

import (
        "strconv"
        "strings"
        "unicode"
)

// Lexer se encarga de convertir el código fuente en una secuencia de tokens.
type Lexer struct {
        source      []rune // El código fuente como un slice de runas para soportar Unicode.
        start       int    // Posición de inicio del token actual.
        current     int    // Posición actual en el slice de runas.
        line        int    // Línea actual.
        column      int    // Columna actual en la línea.
        startLine   int    // Línea de inicio del token actual.
        startColumn int    // Columna de inicio del token actual.
}

// New crea un nuevo Lexer para el código fuente proporcionado.
func New(source string) *Lexer <span class="cov8" title="1">{
        return &amp;Lexer{
                source: []rune(source),
                line:   1,
                column: 1,
        }
}</span>

// isAtEnd comprueba si hemos llegado al final del código fuente.
func (l *Lexer) isAtEnd() bool <span class="cov8" title="1">{
        return l.current &gt;= len(l.source)
}</span>

// advance consume la runa actual y avanza la posición.
func (l *Lexer) advance() rune <span class="cov8" title="1">{
        if l.isAtEnd() </span><span class="cov0" title="0">{
                return 0 // EOF
        }</span>
        <span class="cov8" title="1">r := l.source[l.current]
        l.current++
        if r == '\n' </span><span class="cov8" title="1">{
                l.line++
                l.column = 0 // Se reinicia y el siguiente caracter será la columna 1
        }</span>
        <span class="cov8" title="1">l.column++
        return r</span>
}

// peek devuelve la runa actual sin consumirla.
func (l *Lexer) peek() rune <span class="cov8" title="1">{
        if l.isAtEnd() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return l.source[l.current]</span>
}

// peekNext devuelve la siguiente runa sin consumirla.
func (l *Lexer) peekNext() rune <span class="cov8" title="1">{
        if l.current+1 &gt;= len(l.source) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return l.source[l.current+1]</span>
}

// match comprueba si la runa actual coincide con la esperada. Si es así, la consume.
func (l *Lexer) match(expected rune) bool <span class="cov8" title="1">{
        if l.isAtEnd() || l.source[l.current] != expected </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">l.advance()
        return true</span>
}

// makeToken crea un nuevo token con la información de posición actual.
func (l *Lexer) makeToken(tokenType TokenType, literal interface{}) Token <span class="cov8" title="1">{
        lexeme := string(l.source[l.start:l.current])

        // Para tokens de newline, la posición final es la misma que la inicial
        if tokenType == NEWLINE </span><span class="cov8" title="1">{
                return Token{
                        Type:      tokenType,
                        Lexeme:    lexeme,
                        Literal:   literal,
                        StartLine: l.startLine,
                        StartCol:  l.startColumn,
                        EndLine:   l.startLine,
                        EndCol:    l.startColumn, // Un newline ocupa solo una columna
                }
        }</span>

        // Calcular la posición final correctamente
        <span class="cov8" title="1">endLine := l.startLine
        endCol := l.startColumn + len(lexeme) - 1

        // Si el token contiene newlines, ajustar la posición final
        if l.startLine != l.line </span><span class="cov8" title="1">{
                endLine = l.line
                endCol = l.column - 1
                if endCol &lt; 1 </span><span class="cov0" title="0">{
                        endCol = 1
                }</span>
        }

        <span class="cov8" title="1">return Token{
                Type:      tokenType,
                Lexeme:    lexeme,
                Literal:   literal,
                StartLine: l.startLine,
                StartCol:  l.startColumn,
                EndLine:   endLine,
                EndCol:    endCol,
        }</span>
}

// errorToken crea un token de error.
func (l *Lexer) errorToken(message string) Token <span class="cov0" title="0">{
        return Token{
                Type:      "ERROR",
                Lexeme:    message,
                StartLine: l.line,
                StartCol:  l.column,
                EndLine:   l.line,
                EndCol:    l.column,
        }
}</span>

// skipWhitespace consume todos los espacios en blanco y tabulaciones, pero no los newlines.
func (l *Lexer) skipWhitespace() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                switch l.peek() </span>{
                case ' ', '\r', '\t':<span class="cov8" title="1">
                        l.advance()</span>
                case '\n':<span class="cov8" title="1">
                        // No consumir newlines aquí, dejarlos para que sean tokens
                        return</span>
                case '/':<span class="cov8" title="1">
                        if l.peekNext() == '/' </span><span class="cov8" title="1">{ // Comentario de una línea
                                for l.peek() != '\n' &amp;&amp; !l.isAtEnd() </span><span class="cov8" title="1">{
                                        l.advance()
                                }</span>
                                // No consumir el newline aquí, dejarlo para que sea un token
                        } else<span class="cov0" title="0"> if l.peekNext() == '*' </span><span class="cov0" title="0">{ // Comentario multilínea /* ... */
                                l.advance() // Consume '/'
                                l.advance() // Consume '*'
                                l.skipMultiLineComment()
                        }</span> else<span class="cov0" title="0"> {
                                return
                        }</span>
                case '#':<span class="cov0" title="0"> // Soporte para comentarios de una línea con #
                        for l.peek() != '\n' &amp;&amp; !l.isAtEnd() </span><span class="cov0" title="0">{
                                l.advance()
                        }</span>
                        // No consumir el newline aquí, dejarlo para que sea un token
                default:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// skipMultiLineComment consume un comentario multilínea, incluyendo anidamiento.
func (l *Lexer) skipMultiLineComment() <span class="cov0" title="0">{
        nestingLevel := 1
        for nestingLevel &gt; 0 &amp;&amp; !l.isAtEnd() </span><span class="cov0" title="0">{
                if l.peek() == '*' &amp;&amp; l.peekNext() == '/' </span><span class="cov0" title="0">{
                        l.advance() // Consume '*'
                        l.advance() // Consume '/'
                        nestingLevel--
                }</span> else<span class="cov0" title="0"> if l.peek() == '/' &amp;&amp; l.peekNext() == '*' </span><span class="cov0" title="0">{
                        l.advance() // Consume '/'
                        l.advance() // Consume '*'
                        nestingLevel++
                }</span> else<span class="cov0" title="0"> {
                        l.advance()
                }</span>
        }
        <span class="cov0" title="0">if nestingLevel &gt; 0 </span>{<span class="cov0" title="0">
                // Error: comentario multilínea sin terminar.
                // Por ahora, no emitimos un token de error aquí, pero el lexer podría hacerlo.
        }</span>
}

// isAlpha comprueba si una runa es una letra o un guion bajo.
func isAlpha(r rune) bool <span class="cov8" title="1">{
        return unicode.IsLetter(r) || r == '_'
}</span>

// isDigit comprueba si una runa es un dígito.
func isDigit(r rune) bool <span class="cov8" title="1">{
        return unicode.IsDigit(r)
}</span>

// isHexDigit comprueba si una runa es un dígito hexadecimal.
func isHexDigit(r rune) bool <span class="cov8" title="1">{
        return unicode.IsDigit(r) || (r &gt;= 'a' &amp;&amp; r &lt;= 'f') || (r &gt;= 'A' &amp;&amp; r &lt;= 'F')
}</span>

// identifier procesa un identificador o una palabra clave.
func (l *Lexer) identifier() Token <span class="cov8" title="1">{
        for isAlpha(l.peek()) || isDigit(l.peek()) </span><span class="cov8" title="1">{
                l.advance()
        }</span>
        <span class="cov8" title="1">text := string(l.source[l.start:l.current])
        tokenType, isKeyword := keywords[text]
        if !isKeyword </span><span class="cov8" title="1">{
                tokenType = IDENTIFIER
        }</span>
        <span class="cov8" title="1">return l.makeToken(tokenType, nil)</span>
}

// number procesa un número literal.
func (l *Lexer) number() Token <span class="cov8" title="1">{
        isFloat := false
        for isDigit(l.peek()) </span><span class="cov8" title="1">{
                l.advance()
        }</span>
        <span class="cov8" title="1">if l.peek() == '.' &amp;&amp; isDigit(l.peekNext()) </span><span class="cov8" title="1">{
                isFloat = true
                l.advance() // Consume el '.'
                for isDigit(l.peek()) </span><span class="cov8" title="1">{
                        l.advance()
                }</span>
        }

        <span class="cov8" title="1">lexeme := string(l.source[l.start:l.current])
        if isFloat </span><span class="cov8" title="1">{
                value, err := strconv.ParseFloat(lexeme, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return l.errorToken("Invalid float number.")
                }</span>
                <span class="cov8" title="1">return l.makeToken(NUMBER, value)</span>
        }

        <span class="cov8" title="1">value, err := strconv.ParseInt(lexeme, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return l.errorToken("Invalid integer number.")
        }</span>
        <span class="cov8" title="1">return l.makeToken(NUMBER, value)</span>
}

// stringLiteral procesa una cadena literal entre comillas simples o dobles.
func (l *Lexer) stringLiteral(quote rune) Token <span class="cov8" title="1">{
        var builder strings.Builder
        for </span><span class="cov8" title="1">{
                if l.peek() == quote || l.isAtEnd() </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if l.peek() == '\\' </span><span class="cov8" title="1">{ // Secuencia de escape
                        l.advance() // consume '\'
                        switch l.peek() </span>{
                        case 'n':<span class="cov8" title="1">
                                builder.WriteRune('\n')</span>
                        case 't':<span class="cov0" title="0">
                                builder.WriteRune('\t')</span>
                        case '"':<span class="cov0" title="0">
                                builder.WriteRune('"')</span>
                        case '\'':<span class="cov0" title="0">
                                builder.WriteRune('\'')</span>
                        case '\\':<span class="cov0" title="0">
                                builder.WriteRune('\\')</span>
                        case 'u':<span class="cov8" title="1">
                                l.advance() // consume 'u'
                                hex := make([]rune, 4)
                                for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                                        if !isHexDigit(l.peek()) </span><span class="cov0" title="0">{
                                                return l.errorToken("Invalid Unicode escape sequence: expected 4 hex digits.")
                                        }</span>
                                        <span class="cov8" title="1">hex[i] = l.advance()</span>
                                }
                                <span class="cov8" title="1">hexVal, err := strconv.ParseInt(string(hex), 16, 32)
                                if err != nil </span><span class="cov0" title="0">{
                                        return l.errorToken("Invalid Unicode escape sequence.")
                                }</span>
                                <span class="cov8" title="1">builder.WriteRune(rune(hexVal))
                                continue</span> // Evitar el l.advance() de abajo
                        default:<span class="cov0" title="0">
                                builder.WriteRune('\\')
                                builder.WriteRune(l.peek())</span>
                        }
                        <span class="cov8" title="1">l.advance()</span>
                } else<span class="cov8" title="1"> {
                        // No permitir newlines en strings normales
                        if l.peek() == '\n' </span><span class="cov0" title="0">{
                                return l.errorToken("Unterminated string.")
                        }</span>
                        <span class="cov8" title="1">builder.WriteRune(l.advance())</span>
                }
        }

        <span class="cov8" title="1">if l.isAtEnd() </span><span class="cov0" title="0">{
                return l.errorToken("Unterminated string.")
        }</span>

        <span class="cov8" title="1">l.advance() // Consume la comilla de cierre.
        return l.makeToken(STRING, builder.String())</span>
}

// tripleQuotedStringLiteral procesa una cadena multilínea.
func (l *Lexer) tripleQuotedStringLiteral() Token <span class="cov8" title="1">{
        l.advance() // consume second "
        l.advance() // consume third "

        var builder strings.Builder
        for </span><span class="cov8" title="1">{
                if l.isAtEnd() </span><span class="cov0" title="0">{
                        return l.errorToken("Unterminated multi-line string.")
                }</span>
                <span class="cov8" title="1">if l.peek() == '"' &amp;&amp; l.peekNext() == '"' &amp;&amp; l.peekN(2) == '"' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">builder.WriteRune(l.advance())</span>
        }

        <span class="cov8" title="1">l.advance() // consume first "
        l.advance() // consume second "
        l.advance() // consume third "

        // Eliminar el newline inicial si existe, como en Python
        content := builder.String()
        if len(content) &gt; 0 &amp;&amp; content[0] == '\n' </span><span class="cov8" title="1">{
                content = content[1:]
        }</span>

        <span class="cov8" title="1">return l.makeToken(STRING, content)</span>
}

// peekN devuelve la runa en la posición current + n.
func (l *Lexer) peekN(n int) rune <span class="cov8" title="1">{
        if l.current+n &gt;= len(l.source) </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return l.source[l.current+n]</span>
}

// NextToken escanea y devuelve el siguiente token del código fuente.
func (l *Lexer) NextToken() Token <span class="cov8" title="1">{
        l.skipWhitespace()
        l.start = l.current
        l.startLine = l.line
        l.startColumn = l.column

        if l.isAtEnd() </span><span class="cov8" title="1">{
                return l.makeToken(EOF, nil)
        }</span>

        <span class="cov8" title="1">r := l.advance()

        if isAlpha(r) </span><span class="cov8" title="1">{
                return l.identifier()
        }</span>
        <span class="cov8" title="1">if isDigit(r) </span><span class="cov8" title="1">{
                return l.number()
        }</span>

        <span class="cov8" title="1">switch r </span>{
        case '(':<span class="cov8" title="1">
                return l.makeToken(LEFT_PAREN, nil)</span>
        case ')':<span class="cov8" title="1">
                return l.makeToken(RIGHT_PAREN, nil)</span>
        case '{':<span class="cov8" title="1">
                return l.makeToken(LEFT_BRACE, nil)</span>
        case '}':<span class="cov8" title="1">
                return l.makeToken(RIGHT_BRACE, nil)</span>
        case '[':<span class="cov0" title="0">
                return l.makeToken(LEFT_BRACKET, nil)</span>
        case ']':<span class="cov0" title="0">
                return l.makeToken(RIGHT_BRACKET, nil)</span>
        case ';':<span class="cov8" title="1">
                return l.makeToken(SEMICOLON, nil)</span>
        case ',':<span class="cov8" title="1">
                return l.makeToken(COMMA, nil)</span>
        case '.':<span class="cov0" title="0">
                return l.makeToken(DOT, nil)</span>
        case '-':<span class="cov0" title="0">
                return l.makeToken(MINUS, nil)</span>
        case '+':<span class="cov8" title="1">
                return l.makeToken(PLUS, nil)</span>
        case '/':<span class="cov0" title="0">
                return l.makeToken(SLASH, nil)</span>
        case '*':<span class="cov0" title="0">
                return l.makeToken(STAR, nil)</span>
        case '%':<span class="cov0" title="0">
                return l.makeToken(PERCENT, nil)</span>
        case ':':<span class="cov0" title="0">
                return l.makeToken(COLON, nil)</span>
        case '!':<span class="cov0" title="0">
                if l.match('=') </span><span class="cov0" title="0">{
                        return l.makeToken(BANG_EQUAL, nil)
                }</span>
                <span class="cov0" title="0">return l.makeToken(BANG, nil)</span>
        case '=':<span class="cov8" title="1">
                if l.match('=') </span><span class="cov0" title="0">{
                        return l.makeToken(EQUAL_EQUAL, nil)
                }</span>
                <span class="cov8" title="1">if l.match('&gt;') </span><span class="cov0" title="0">{
                        return l.makeToken(ARROW, nil)
                }</span>
                <span class="cov8" title="1">return l.makeToken(EQUAL, nil)</span>
        case '&lt;':<span class="cov0" title="0">
                if l.match('=') </span><span class="cov0" title="0">{
                        return l.makeToken(LESS_EQUAL, nil)
                }</span>
                <span class="cov0" title="0">return l.makeToken(LESS, nil)</span>
        case '&gt;':<span class="cov0" title="0">
                if l.match('=') </span><span class="cov0" title="0">{
                        return l.makeToken(GREATER_EQUAL, nil)
                }</span>
                <span class="cov0" title="0">return l.makeToken(GREATER, nil)</span>
        case '&amp;':<span class="cov0" title="0">
                if l.match('&amp;') </span><span class="cov0" title="0">{
                        return l.makeToken(AND, nil)
                }</span>
                <span class="cov0" title="0">return l.errorToken("Unexpected character '&amp;'. Did you mean '&amp;&amp;'?")</span>
        case '|':<span class="cov0" title="0">
                if l.match('|') </span><span class="cov0" title="0">{
                        return l.makeToken(OR, nil)
                }</span>
                <span class="cov0" title="0">return l.errorToken("Unexpected character '|'. Did you mean '||'?")</span>
        case '\n':<span class="cov8" title="1">
                return l.makeToken(NEWLINE, nil)</span>
        case '"':<span class="cov8" title="1">
                if l.peek() == '"' &amp;&amp; l.peekNext() == '"' </span><span class="cov8" title="1">{
                        return l.tripleQuotedStringLiteral()
                }</span>
                <span class="cov8" title="1">return l.stringLiteral('"')</span>
        case '\'':<span class="cov8" title="1">
                return l.stringLiteral('\'')</span>
        }

        <span class="cov0" title="0">return l.errorToken("Unexpected character.")</span>
}

var keywords = map[string]TokenType{
        "and":      AND,
        "class":    CLASS,
        "else":     ELSE,
        "false":    FALSE,
        "for":      FOR,
        "func":     FUNC,
        "if":       IF,
        "nil":      NIL,
        "or":       OR,
        "return":   RETURN,
        "super":    SUPER,
        "this":     THIS,
        "true":     TRUE,
        "var":      VAR,
        "const":    CONST,
        "while":    WHILE,
        "break":    BREAK,
        "continue": CONTINUE,
        "elif":     ELIF,
        // "show" and "log" are treated as regular identifiers for member access
        "import":   IMPORT,
        "from":     FROM,
        "try":      TRY,
        "catch":    CATCH,
        "throw":    THROW,
        "finally":  FINALLY,
        "async":    ASYNC,
        "await":    AWAIT,
        "spawn":    SPAWN,
        "in":       IN,
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package lexer

import "fmt"

// TokenType es un string que representa el tipo de un token.
type TokenType string

// Token representa una unidad léxica del lenguaje Zylo.
type Token struct {
        Type      TokenType // El tipo del token (e.g., IDENTIFIER, NUMBER).
        Lexeme    string    // El substring del código fuente que representa el token.
        Literal   interface{} // El valor literal del token, si aplica (e.g., 123, "hello").
        StartLine int       // La línea donde comienza el token.
        StartCol  int       // La columna donde comienza el token.
        EndLine   int       // La línea donde termina el token.
        EndCol    int       // La columna donde termina el token.
}

// String devuelve una representación legible del token, útil para debugging.
func (t Token) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Token(Type: %s, Lexeme: '%s', Literal: %v, Pos: %d:%d-%d:%d)",
                t.Type, t.Lexeme, t.Literal, t.StartLine, t.StartCol, t.EndLine, t.EndCol)
}</span>

// Constantes para los tipos de token.
const (
        // Tokens de un solo carácter
        LEFT_PAREN  TokenType = "LEFT_PAREN"
        RIGHT_PAREN TokenType = "RIGHT_PAREN"
        LEFT_BRACE  TokenType = "LEFT_BRACE"
        RIGHT_BRACE TokenType = "RIGHT_BRACE"
        LEFT_BRACKET TokenType = "LEFT_BRACKET"
        RIGHT_BRACKET TokenType = "RIGHT_BRACKET"
        COMMA       TokenType = "COMMA"
        DOT         TokenType = "DOT"
        MINUS       TokenType = "MINUS"
        PLUS        TokenType = "PLUS"
        SEMICOLON   TokenType = "SEMICOLON"
        SLASH       TokenType = "SLASH"
        STAR        TokenType = "STAR"
        PERCENT     TokenType = "PERCENT"
        COLON       TokenType = "COLON"

        // Tokens de uno o dos caracteres
        BANG          TokenType = "BANG"
        BANG_EQUAL    TokenType = "BANG_EQUAL"
        EQUAL         TokenType = "EQUAL"
        EQUAL_EQUAL   TokenType = "EQUAL_EQUAL"
        GREATER       TokenType = "GREATER"
        GREATER_EQUAL TokenType = "GREATER_EQUAL"
        LESS          TokenType = "LESS"
        LESS_EQUAL    TokenType = "LESS_EQUAL"
        ARROW         TokenType = "ARROW" // =&gt;

        // Literales
        IDENTIFIER TokenType = "IDENTIFIER"
        STRING     TokenType = "STRING"
        NUMBER     TokenType = "NUMBER"

        // Palabras clave
        AND      TokenType = "AND"
        CLASS    TokenType = "CLASS"
        ELSE     TokenType = "ELSE"
        ELIF     TokenType = "ELIF"
        FALSE    TokenType = "FALSE"
        FOR      TokenType = "FOR"
        FUNC     TokenType = "FUNC"
        IF       TokenType = "IF"
        NIL      TokenType = "NIL"
        OR       TokenType = "OR"
        RETURN   TokenType = "RETURN"
        SUPER    TokenType = "SUPER" // Placeholder, puede cambiar
        THIS     TokenType = "THIS"    // Placeholder, puede cambiar
        TRUE     TokenType = "TRUE"
        VAR      TokenType = "VAR"
        CONST    TokenType = "CONST"
        WHILE    TokenType = "WHILE"
        BREAK    TokenType = "BREAK"
        CONTINUE TokenType = "CONTINUE"
        SHOW     TokenType = "SHOW"
        LOG      TokenType = "LOG"
        IMPORT   TokenType = "IMPORT"
        FROM     TokenType = "FROM"
        TRY      TokenType = "TRY"
        CATCH    TokenType = "CATCH"
        THROW    TokenType = "THROW"
        FINALLY  TokenType = "FINALLY"
        ASYNC    TokenType = "ASYNC"
        AWAIT    TokenType = "AWAIT"
        SPAWN    TokenType = "SPAWN"
        IN       TokenType = "IN"

        // Control
        NEWLINE TokenType = "NEWLINE"
        EOF     TokenType = "EOF"
)
</pre>
		
		<pre class="file" id="file7" style="display: none">        package parser

        import (
                "context"
                "fmt"
                "time"

                "github.com/zylo-lang/zylo/internal/ast"
                "github.com/zylo-lang/zylo/internal/lexer"
        )

        // Parser toma una secuencia de tokens y construye un AST.
        type Parser struct {
                l      *lexer.Lexer
                errors []string

                curToken  lexer.Token
                peekToken lexer.Token

                // Protecciones contra memory leak
                recursionDepth    int
                maxRecursionDepth int
                maxErrors         int

                // Funciones de parsing para prefijos y sufijos.
                prefixParseFns map[lexer.TokenType]prefixParseFn
                infixParseFns  map[lexer.TokenType]infixParseFn
        }

        // prefixParseFn es el tipo para funciones que parsean expresiones prefijo.
        type prefixParseFn func() ast.Expression

        // infixParseFn es el tipo para funciones que parsean expresiones infijo.
        type infixParseFn func(ast.Expression) ast.Expression

        // New crea un nuevo Parser.
        func New(l *lexer.Lexer) *Parser <span class="cov8" title="1">{
                p := &amp;Parser{
                        l:                 l,
                        errors:            []string{},
                        maxRecursionDepth: 1000,
                        maxErrors:         100,
                }
        
                p.prefixParseFns = make(map[lexer.TokenType]prefixParseFn)
                p.infixParseFns = make(map[lexer.TokenType]infixParseFn)
        
                // LITERALES Y IDENTIFICADORES
                p.registerPrefix(lexer.IDENTIFIER, p.parseIdentifier)
                p.registerPrefix(lexer.NUMBER, p.parseNumberLiteral)
                p.registerPrefix(lexer.STRING, p.parseStringLiteral)
                p.registerPrefix(lexer.TRUE, p.parseBooleanLiteral)
                p.registerPrefix(lexer.FALSE, p.parseBooleanLiteral)
                p.registerPrefix(lexer.NIL, p.parseNullLiteral)
        
                // OPERADORES PREFIJO
                p.registerPrefix(lexer.BANG, p.parsePrefixExpression)
                p.registerPrefix(lexer.MINUS, p.parsePrefixExpression)
                p.registerPrefix(lexer.PLUS, p.parsePrefixExpression) // +num
        
                // AGRUPACIÓN Y ESTRUCTURAS
                p.registerPrefix(lexer.LEFT_PAREN, p.parseGroupedExpression)
                p.registerPrefix(lexer.LEFT_BRACE, p.parseHashLiteral) // Para objetos {}
                p.registerPrefix(lexer.LEFT_BRACKET, p.parseListLiteral) // Para arrays []
        
                // PALABRAS CLAVE QUE PUEDEN SER EXPRESIONES
                p.registerPrefix(lexer.THIS, p.parseThisExpression)
                p.registerPrefix(lexer.SUPER, p.parseSuperExpression)
                p.registerPrefix(lexer.FUNC, p.parseFunctionLiteral) // Funciones anónimas
                p.registerPrefix(lexer.IMPORT, p.parseImportExpression) // Import como expresión
                p.registerPrefix(lexer.ELIF, func() ast.Expression </span><span class="cov0" title="0">{
                        // ELIF no debería ser una expresión, devolver error controlado
                        p.addError("elif must be used after if statement")
                        return &amp;ast.Identifier{Token: p.curToken, Value: "ERROR"}
                }</span>)
        
                // OPERADORES INFIJO
                <span class="cov8" title="1">p.registerInfix(lexer.PLUS, p.parseInfixExpression)
                p.registerInfix(lexer.MINUS, p.parseInfixExpression)
                p.registerInfix(lexer.STAR, p.parseInfixExpression)
                p.registerInfix(lexer.SLASH, p.parseInfixExpression)
                p.registerInfix(lexer.PERCENT, p.parseInfixExpression)
        
                // COMPARACIÓN
                p.registerInfix(lexer.EQUAL_EQUAL, p.parseInfixExpression)
                p.registerInfix(lexer.BANG_EQUAL, p.parseInfixExpression)
                p.registerInfix(lexer.LESS, p.parseInfixExpression)
                p.registerInfix(lexer.LESS_EQUAL, p.parseInfixExpression)
                p.registerInfix(lexer.GREATER, p.parseInfixExpression)
                p.registerInfix(lexer.GREATER_EQUAL, p.parseInfixExpression)
        
                // LÓGICOS
                p.registerInfix(lexer.AND, p.parseInfixExpression)
                p.registerInfix(lexer.OR, p.parseInfixExpression)
        
                // ASIGNACIÓN
                p.registerInfix(lexer.EQUAL, p.parseInfixExpression)
        
                // ACCESO
                p.registerInfix(lexer.LEFT_PAREN, func(left ast.Expression) ast.Expression </span><span class="cov8" title="1">{
                        return p.parseCallExpression(left)
                }</span>)
                <span class="cov8" title="1">p.registerInfix(lexer.LEFT_BRACKET, func(left ast.Expression) ast.Expression </span><span class="cov0" title="0">{
                        return p.parseIndexExpression(left)
                }</span>)
                <span class="cov8" title="1">p.registerInfix(lexer.DOT, p.parseDotExpression)
        
                p.nextToken()
                p.nextToken()
        
                return p</span>
        }

        // registerPrefix registra una función de parsing prefijo.
        func (p *Parser) registerPrefix(tokenType lexer.TokenType, fn prefixParseFn) <span class="cov8" title="1">{
                p.prefixParseFns[tokenType] = fn
        }</span>

        // registerInfix registra una función de parsing infijo.
        func (p *Parser) registerInfix(tokenType lexer.TokenType, fn infixParseFn) <span class="cov8" title="1">{
                p.infixParseFns[tokenType] = fn
        }</span>

        // ParseProgram es el punto de entrada para el parsing.
        func (p *Parser) ParseProgram() *ast.Program <span class="cov8" title="1">{
                return p.ParseProgramWithTimeout(30 * time.Second)
        }</span>

        // ParseProgramWithTimeout - con debugging y protección extra
        func (p *Parser) ParseProgramWithTimeout(timeout time.Duration) *ast.Program <span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(context.Background(), timeout)
                defer cancel()

                program := &amp;ast.Program{}
                program.Statements = []ast.Statement{}

                iterations := 0 // Contador de seguridad

                // Saltar tokens NEWLINE iniciales
                for p.curToken.Type == lexer.NEWLINE &amp;&amp; p.curToken.Type != lexer.EOF </span><span class="cov8" title="1">{
                        p.nextToken()
                }</span>

                <span class="cov8" title="1">for p.curToken.Type != lexer.EOF </span><span class="cov8" title="1">{
                        iterations++
                        if iterations &gt; 1000 </span><span class="cov0" title="0">{ // Límite de seguridad
                                p.addError("too many iterations - possible infinite loop")
                                break</span>
                        }

                        <span class="cov8" title="1">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                p.addError("parsing timeout")
                                return program</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        // Guardar token actual para detectar si avanzamos
                        <span class="cov8" title="1">currentTokenType := p.curToken.Type

                        stmt := p.parseStatement()
                        if stmt != nil </span><span class="cov8" title="1">{
                                program.Statements = append(program.Statements, stmt)
                        }</span>

                        // CRÍTICO: Siempre avanzar si no cambió el token
                        <span class="cov8" title="1">if p.curToken.Type == currentTokenType </span><span class="cov8" title="1">{
                                p.nextToken()
                        }</span>

                        <span class="cov8" title="1">if len(program.Statements) &gt; 1000 </span><span class="cov0" title="0">{
                                p.addError("too many statements")
                                break</span>
                        }
                }

                <span class="cov8" title="1">return program</span>
        }

        // Errors devuelve la lista de errores encontrados durante el parsing.
        func (p *Parser) Errors() []string <span class="cov8" title="1">{
                return p.errors
        }</span>

        // Funciones helper para control de recursión
        func (p *Parser) enterRecursion() error <span class="cov0" title="0">{
                p.recursionDepth++
                if p.recursionDepth &gt; p.maxRecursionDepth </span><span class="cov0" title="0">{
                        return fmt.Errorf("máxima profundidad de recursión alcanzada (%d)", p.maxRecursionDepth)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        func (p *Parser) exitRecursion() <span class="cov0" title="0">{
                p.recursionDepth--
        }</span>

        // addError añade un error con protección contra overflow
        func (p *Parser) addError(msg string) <span class="cov0" title="0">{
                if len(p.errors) &lt; p.maxErrors </span><span class="cov0" title="0">{
                        p.errors = append(p.errors, msg)
                }</span>
        }

        // noPrefixParseFnError añade un error cuando no hay función de parsing prefijo
        func (p *Parser) noPrefixParseFnError(t lexer.TokenType) <span class="cov0" title="0">{
                msg := fmt.Sprintf("no prefix parse function for %s found", t)
                p.addError(msg)
        }</span>

        // parseImportStatement analiza una declaración de import.
        func (p *Parser) parseImportStatement() *ast.ImportStatement <span class="cov0" title="0">{
                stmt := &amp;ast.ImportStatement{Token: p.curToken}

                if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">stmt.ModuleName = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}

                // Skip newlines after import statement
                for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>

                <span class="cov0" title="0">return stmt</span>
        }

        // parseImportExpression analiza import como expresión (para casos donde aparece en contexto de expresión)
        func (p *Parser) parseImportExpression() ast.Expression <span class="cov0" title="0">{
                stmt := &amp;ast.ImportStatement{Token: p.curToken}

                if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">stmt.ModuleName = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}

                return stmt</span>
        }

        // parseBreakStatement analiza una sentencia 'break'.
        func (p *Parser) parseBreakStatement() *ast.BreakStatement <span class="cov0" title="0">{
                stmt := &amp;ast.BreakStatement{Token: p.curToken}
                return stmt
        }</span>

        // parseContinueStatement analiza una sentencia 'continue'.
        func (p *Parser) parseContinueStatement() *ast.ContinueStatement <span class="cov0" title="0">{
                stmt := &amp;ast.ContinueStatement{Token: p.curToken}
                return stmt
        }</span>

        // parseElifStatement analiza una sentencia 'elif' - esto se trata como un if anidado
        func (p *Parser) parseElifStatement() ast.Statement <span class="cov0" title="0">{
                // 'elif' se convierte en 'if' para el parser
                return p.parseIfStatement()
        }</span>

        // AGREGAR parseStatement mejorado que maneje ELIF correctamente
        func (p *Parser) parseStatement() ast.Statement <span class="cov8" title="1">{
                switch p.curToken.Type </span>{
                case lexer.IMPORT:<span class="cov0" title="0">
                        return p.parseImportStatement()</span>
                case lexer.VAR:<span class="cov8" title="1">
                        return p.parseVarStatement()</span>
                case lexer.FUNC:<span class="cov8" title="1">
                        return p.parseFuncStatement()</span>
                case lexer.RETURN:<span class="cov0" title="0">
                        return p.parseReturnStatement()</span>
                case lexer.IF:<span class="cov8" title="1">
                        return p.parseIfStatement()</span>
                case lexer.ELIF:<span class="cov0" title="0">
                        // ELIF solo es válido después de IF, tratar como error
                        p.addError("elif without preceding if statement")
                        return nil</span>
                case lexer.WHILE:<span class="cov0" title="0">
                        return p.parseWhileStatement()</span>
                case lexer.FOR:<span class="cov0" title="0">
                        return p.parseForStatement()</span>
                case lexer.TRY:<span class="cov0" title="0">
                        return p.parseTryStatement()</span>
                case lexer.CLASS:<span class="cov0" title="0">
                        return p.parseClassStatement()</span>
                case lexer.BREAK:<span class="cov0" title="0">
                        return p.parseBreakStatement()</span>
                case lexer.CONTINUE:<span class="cov0" title="0">
                        return p.parseContinueStatement()</span>
                case lexer.THROW:<span class="cov0" title="0">
                        return p.parseThrowStatement()</span>
                case lexer.SEMICOLON, lexer.NEWLINE:<span class="cov8" title="1">
                        return nil</span>
                case lexer.RIGHT_BRACE:<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov8" title="1">
                        return p.parseExpressionStatement()</span>
                }
        }

        func (p *Parser) parseVarStatement() *ast.VarStatement <span class="cov8" title="1">{
                stmt := &amp;ast.VarStatement{Token: p.curToken}

                if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}

                // CRÍTICO: Manejar tipo opcional ": Float" o ": Array&lt;String&gt;"
                if p.peekTokenIs(lexer.COLON) </span><span class="cov0" title="0">{
                        p.nextToken() // consumir ':'
                        if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        // Opcional: guardar tipo de variable
                        // stmt.Type = p.curToken.Lexeme

                        // Manejar tipos genéricos como Array&lt;String&gt;
                        <span class="cov0" title="0">if p.peekTokenIs(lexer.LESS) </span><span class="cov0" title="0">{
                                p.nextToken() // consume &lt;
                                if p.expectPeek(lexer.IDENTIFIER) </span>{<span class="cov0" title="0">
                                        // Tipo parámetro, ignorar por ahora
                                }</span>
                                <span class="cov0" title="0">p.expectPeek(lexer.GREATER)</span> // consume &gt;
                        }
                }

                <span class="cov8" title="1">if p.peekTokenIs(lexer.EQUAL) </span><span class="cov8" title="1">{
                        p.nextToken() // consume =
                        p.nextToken()
                        stmt.Value = p.parseExpression(LOWEST)
                }</span>

                <span class="cov8" title="1">if p.peekTokenIs(lexer.SEMICOLON) </span><span class="cov8" title="1">{
                        p.nextToken()
                }</span>

                <span class="cov8" title="1">return stmt</span>
        }

        func (p *Parser) parseReturnStatement() *ast.ReturnStatement <span class="cov0" title="0">{
                stmt := &amp;ast.ReturnStatement{Token: p.curToken}

                p.nextToken()
                if !p.curTokenIs(lexer.SEMICOLON) &amp;&amp; !p.curTokenIs(lexer.NEWLINE) &amp;&amp; !p.curTokenIs(lexer.RIGHT_BRACE) </span><span class="cov0" title="0">{
                        stmt.ReturnValue = p.parseExpression(LOWEST)
                }</span>

                <span class="cov0" title="0">if p.peekTokenIs(lexer.SEMICOLON) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>

                <span class="cov0" title="0">return stmt</span>
        }

        func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement <span class="cov8" title="1">{
                // Verificar que el token actual puede ser una expresión
                if p.curToken.Type == lexer.RIGHT_PAREN ||
                   p.curToken.Type == lexer.ELSE ||
                   p.curToken.Type == lexer.CATCH </span><span class="cov0" title="0">{
                        // Estos no son expresiones válidas, devolver nil
                        return nil
                }</span>

                <span class="cov8" title="1">stmt := &amp;ast.ExpressionStatement{Token: p.curToken}
                stmt.Expression = p.parseExpression(LOWEST)

                // CRÍTICO: Si la expresión es nil, devolver nil en lugar del statement
                if stmt.Expression == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Consumir ; si está presente
                <span class="cov8" title="1">if p.peekTokenIs(lexer.SEMICOLON) </span><span class="cov8" title="1">{
                        p.nextToken()
                }</span>

                <span class="cov8" title="1">return stmt</span>
        }

// ARREGLAR parseFuncStatement para el error "expected LEFT_BRACE, got NUMBER"
func (p *Parser) parseFuncStatement() *ast.FuncStatement <span class="cov8" title="1">{
        stmt := &amp;ast.FuncStatement{Token: p.curToken}

        if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}

        if !p.expectPeek(lexer.LEFT_PAREN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">stmt.Parameters = p.parseFunctionParameters()

        // CRÍTICO: Manejar tipo de retorno opcional sin consumir tokens incorrectos
        if p.peekTokenIs(lexer.COLON) </span><span class="cov0" title="0">{
                p.nextToken() // consume :
                if p.expectPeek(lexer.IDENTIFIER) </span>{<span class="cov0" title="0">
                        // stmt.ReturnType = p.curToken.Lexeme
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov8" title="1"> if p.peekTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                // Tipo sin dos puntos
                p.nextToken()
                // stmt.ReturnType = p.curToken.Lexeme
        }</span>

        // Skip newlines antes de {
        <span class="cov8" title="1">for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                p.nextToken()
        }</span>

        <span class="cov8" title="1">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">stmt.Body = p.parseBlockStatement()
        return stmt</span>
}

        func (p *Parser) parseFunctionParameters() []*ast.Identifier <span class="cov8" title="1">{
                var identifiers []*ast.Identifier

                if p.peekTokenIs(lexer.RIGHT_PAREN) </span><span class="cov8" title="1">{
                        p.nextToken()
                        return identifiers
                }</span>

                <span class="cov0" title="0">p.nextToken()
                
                ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}
                identifiers = append(identifiers, ident)

                // Soportar tipos opcionales como (nombre: String)
                if p.peekTokenIs(lexer.COLON) </span><span class="cov0" title="0">{
                        p.nextToken() // consumir ':'
                        p.nextToken() // consumir tipo
                        // Ignorar el tipo por ahora
                }</span>

                <span class="cov0" title="0">for p.peekTokenIs(lexer.COMMA) </span><span class="cov0" title="0">{
                        p.nextToken() // consumir ','
                        p.nextToken() // avanzar a parámetro
                        
                        ident := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}
                        identifiers = append(identifiers, ident)

                        // Soportar tipos opcionales
                        if p.peekTokenIs(lexer.COLON) </span><span class="cov0" title="0">{
                                p.nextToken() // consumir ':'
                                p.nextToken() // consumir tipo
                        }</span>
                }

                <span class="cov0" title="0">if !p.expectPeek(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return identifiers</span>
        }



        // Helper functions
        func (p *Parser) nextToken() <span class="cov8" title="1">{
                p.curToken = p.peekToken
                p.peekToken = p.l.NextToken()
        }</span>

        func (p *Parser) curTokenIs(t lexer.TokenType) bool <span class="cov8" title="1">{
                return p.curToken.Type == t
        }</span>

        func (p *Parser) peekTokenIs(t lexer.TokenType) bool <span class="cov8" title="1">{
                return p.peekToken.Type == t
        }</span>

        func (p *Parser) expectPeek(t lexer.TokenType) bool <span class="cov8" title="1">{
                if p.peekTokenIs(t) </span><span class="cov8" title="1">{
                        p.nextToken()
                        return true
                }</span>
                <span class="cov0" title="0">p.peekError(t)
                return false</span>
        }

        func (p *Parser) peekError(t lexer.TokenType) <span class="cov0" title="0">{
                msg := fmt.Sprintf("expected next token to be %s, got %s instead",
                        t, p.peekToken.Type)
                p.addError(msg)
        }</span>

        // Parsing functions (minimal implementations)
        func (p *Parser) parseIdentifier() ast.Expression <span class="cov8" title="1">{
                return &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}
        }</span>

        func (p *Parser) parseNumberLiteral() ast.Expression <span class="cov8" title="1">{
                lit := &amp;ast.NumberLiteral{Token: p.curToken}
                if p.curToken.Literal != nil </span><span class="cov8" title="1">{
                        lit.Value = p.curToken.Literal
                }</span> else<span class="cov0" title="0"> {
                        lit.Value = int64(0)
                }</span>
                <span class="cov8" title="1">return lit</span>
        }

        func (p *Parser) parseStringLiteral() ast.Expression <span class="cov8" title="1">{
                lit := &amp;ast.StringLiteral{Token: p.curToken}
                if p.curToken.Literal != nil </span><span class="cov8" title="1">{
                        if val, ok := p.curToken.Literal.(string); ok </span><span class="cov8" title="1">{
                                lit.Value = val
                        }</span> else<span class="cov0" title="0"> {
                                lit.Value = ""
                        }</span>
                } else<span class="cov0" title="0"> {
                        lit.Value = ""
                }</span>
                <span class="cov8" title="1">return lit</span>
        }

        func (p *Parser) parseBooleanLiteral() ast.Expression <span class="cov0" title="0">{
                return &amp;ast.BooleanLiteral{
                        Token: p.curToken,
                        Value: p.curToken.Type == lexer.TRUE,
                }
        }</span>

        func (p *Parser) parseNullLiteral() ast.Expression <span class="cov0" title="0">{
                return &amp;ast.NullLiteral{Token: p.curToken}
        }</span>

        func (p *Parser) parsePrefixExpression() ast.Expression <span class="cov0" title="0">{
                return &amp;ast.PrefixExpression{
                        Token:    p.curToken,
                        Operator: p.curToken.Lexeme,
                }
        }</span>

        func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression <span class="cov8" title="1">{
                exp := &amp;ast.InfixExpression{
                        Token:    p.curToken,
                        Left:     left,
                        Operator: p.curToken.Lexeme,
                }

                precedence := p.currentPrecedence()
                p.nextToken() // consume operator
                exp.Right = p.parseExpression(precedence)

                return exp
        }</span>

        func (p *Parser) parseGroupedExpression() ast.Expression <span class="cov0" title="0">{
                p.nextToken()
                exp := p.parseExpression(LOWEST)
                p.expectPeek(lexer.RIGHT_PAREN)
                return exp
        }</span>

        func (p *Parser) parseCallExpression(left ast.Expression) ast.Expression <span class="cov8" title="1">{
                exp := &amp;ast.CallExpression{
                        Token:     p.curToken,
                        Function:  left,
                        Arguments: []ast.Expression{},
                }

                // Parse arguments
                if !p.peekTokenIs(lexer.RIGHT_PAREN) </span><span class="cov8" title="1">{
                        p.nextToken() // move to first argument
                        exp.Arguments = append(exp.Arguments, p.parseExpression(LOWEST))

                        for p.peekTokenIs(lexer.COMMA) </span><span class="cov0" title="0">{
                                p.nextToken() // consume ,
                                p.nextToken() // move to next argument
                                exp.Arguments = append(exp.Arguments, p.parseExpression(LOWEST))
                        }</span>
                }

                <span class="cov8" title="1">if !p.expectPeek(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">return exp</span>
        }

        func (p *Parser) parseIndexExpression(left ast.Expression) ast.Expression <span class="cov0" title="0">{
                exp := &amp;ast.IndexExpression{
                        Token: p.curToken,
                        Left:  left,
                }
                p.nextToken() // consume [
                exp.Index = p.parseExpression(LOWEST)
                if !p.expectPeek(lexer.RIGHT_BRACKET) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return exp</span>
        }

        func (p *Parser) parseDotExpression(left ast.Expression) ast.Expression <span class="cov0" title="0">{
                if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">prop := &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}

                memberExp := &amp;ast.MemberExpression{
                        Token:    p.curToken,
                        Object:   left,
                        Property: prop,
                }

                // Si hay paréntesis, es una llamada a método como show.log()
                if p.peekTokenIs(lexer.LEFT_PAREN) </span><span class="cov0" title="0">{
                        p.nextToken() // consumir '('
                        return p.parseCallExpression(memberExp)
                }</span>

                <span class="cov0" title="0">return memberExp</span>
        }

        func (p *Parser) parseExpression(precedence int) ast.Expression <span class="cov8" title="1">{
                prefix := p.prefixParseFns[p.curToken.Type]
                if prefix == nil </span><span class="cov0" title="0">{
                        if p.curToken.Type == lexer.RIGHT_BRACKET </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">p.noPrefixParseFnError(p.curToken.Type)
                        return nil</span>
                }

                <span class="cov8" title="1">leftExp := prefix()
                if leftExp == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">iterations := 0
                for precedence &lt; p.peekPrecedence() &amp;&amp; iterations &lt; 50 </span><span class="cov8" title="1">{
                        iterations++

                        infix := p.infixParseFns[p.peekToken.Type]
                        if infix == nil </span><span class="cov0" title="0">{
                                return leftExp
                        }</span>

                        <span class="cov8" title="1">p.nextToken()
                        newLeftExp := infix(leftExp)

                        if newLeftExp == nil </span><span class="cov0" title="0">{
                                return leftExp
                        }</span>

                        <span class="cov8" title="1">leftExp = newLeftExp</span>
                }

                <span class="cov8" title="1">return leftExp</span>
        }

        func (p *Parser) currentPrecedence() int <span class="cov8" title="1">{
                if p, ok := precedences[p.curToken.Type]; ok </span><span class="cov8" title="1">{
                        return p
                }</span>
                <span class="cov0" title="0">return LOWEST</span>
        }

        func (p *Parser) peekPrecedence() int <span class="cov8" title="1">{
                if p, ok := precedences[p.peekToken.Type]; ok </span><span class="cov8" title="1">{
                        return p
                }</span>
                <span class="cov8" title="1">return LOWEST</span>
        }

        func (p *Parser) parseBlockExpression() ast.Expression <span class="cov0" title="0">{
                return &amp;ast.BlockExpression{Token: p.curToken}
        }</span>

        func (p *Parser) parseBlockStatement() *ast.BlockStatement <span class="cov8" title="1">{
                block := &amp;ast.BlockStatement{Token: p.curToken, Statements: []ast.Statement{}}

                if !p.curTokenIs(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                        p.addError("expected '{' to start block")
                        return nil
                }</span>
                <span class="cov8" title="1">p.nextToken() // consume {

                iterations := 0
                for !p.curTokenIs(lexer.RIGHT_BRACE) &amp;&amp; !p.curTokenIs(lexer.EOF) </span><span class="cov8" title="1">{
                        iterations++
                        if iterations &gt; 100 </span><span class="cov0" title="0">{
                                p.addError("too many iterations in parseBlockStatement")
                                break</span>
                        }

                        // Skip newlines
                        <span class="cov8" title="1">if p.curTokenIs(lexer.NEWLINE) </span><span class="cov8" title="1">{
                                p.nextToken()
                                continue</span>
                        }

                        // CRÍTICO: Detener si encontramos tokens que no deberían estar aquí
                        <span class="cov8" title="1">if p.curToken.Type == lexer.RIGHT_PAREN ||
                           p.curToken.Type == lexer.ELSE ||
                           p.curToken.Type == lexer.CATCH </span><span class="cov0" title="0">{
                                // Estos tokens indican fin de bloque o tokens mal posicionados
                                break</span>
                        }

                        <span class="cov8" title="1">currentToken := p.curToken.Type
                        stmt := p.parseStatement()

                        if stmt != nil </span><span class="cov8" title="1">{
                                block.Statements = append(block.Statements, stmt)
                        }</span>

                        // Protección contra bucles infinitos
                        <span class="cov8" title="1">if p.curToken.Type == currentToken </span><span class="cov8" title="1">{
                                p.nextToken()
                        }</span>
                }

                <span class="cov8" title="1">if p.curTokenIs(lexer.RIGHT_BRACE) </span><span class="cov8" title="1">{
                        p.nextToken() // consume }
                }</span>

                <span class="cov8" title="1">return block</span>
        }

        // ARREGLAR parseExpressionList completamente para COMMA y RIGHT_BRACKET
                func (p *Parser) parseExpressionList(end lexer.TokenType) []ast.Expression <span class="cov0" title="0">{
                        args := []ast.Expression{}
        
                        // Lista vacía - si el siguiente token es el de cierre
                        if p.peekTokenIs(end) </span><span class="cov0" title="0">{
                                p.nextToken() // consume closing token
                                return args
                        }</span>
        
                        // Avanzar al primer elemento
                        <span class="cov0" title="0">p.nextToken()
        
                        // Parsear primer elemento si no es el token de cierre
                        if !p.curTokenIs(end) </span><span class="cov0" title="0">{
                                expr := p.parseExpression(LOWEST)
                                if expr != nil </span><span class="cov0" title="0">{
                                        args = append(args, expr)
                                }</span>
        
                                // Parsear elementos adicionales separados por comas
                                <span class="cov0" title="0">for p.peekTokenIs(lexer.COMMA) </span><span class="cov0" title="0">{
                                        p.nextToken() // consume comma
                                        p.nextToken() // move to next expression
        
                                        if p.curTokenIs(end) </span><span class="cov0" title="0">{
                                                // Coma trailing, terminar
                                                break</span>
                                        }
        
                                        <span class="cov0" title="0">expr := p.parseExpression(LOWEST)
                                        if expr != nil </span><span class="cov0" title="0">{
                                                args = append(args, expr)
                                        }</span>
                                }
                        }
        
                        <span class="cov0" title="0">if !p.expectPeek(end) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
        
                        <span class="cov0" title="0">return args</span>
                }

// MEJORAR parseListLiteral para manejar arrays correctamente
func (p *Parser) parseListLiteral() ast.Expression <span class="cov0" title="0">{
        lit := &amp;ast.ListLiteral{Token: p.curToken, Elements: []ast.Expression{}}

        // Array vacío []
        if p.peekTokenIs(lexer.RIGHT_BRACKET) </span><span class="cov0" title="0">{
                p.nextToken() // consume ]
                return lit
        }</span>

        // Usar parseExpressionList mejorado
        <span class="cov0" title="0">lit.Elements = p.parseExpressionList(lexer.RIGHT_BRACKET)
        return lit</span>
}

// parseIfStatement con manejo de paréntesis mejorado:
func (p *Parser) parseIfStatement() *ast.IfStatement <span class="cov8" title="1">{
        stmt := &amp;ast.IfStatement{Token: p.curToken}

        p.nextToken() // consume IF

        // Detectar si hay paréntesis
        hasParens := p.curTokenIs(lexer.LEFT_PAREN)
        if hasParens </span><span class="cov8" title="1">{
                p.nextToken() // consume (
        }</span>

        <span class="cov8" title="1">stmt.Condition = p.parseExpression(LOWEST)

        if hasParens </span><span class="cov8" title="1">{
                if !p.expectPeek(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Skip newlines
        <span class="cov8" title="1">for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                p.nextToken()
        }</span>

        <span class="cov8" title="1">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">stmt.Consequence = p.parseBlockStatement()

        // Manejar else o elif
        if p.curTokenIs(lexer.ELSE) || p.curTokenIs(lexer.ELIF) </span><span class="cov8" title="1">{
                if p.peekTokenIs(lexer.LEFT_BRACE) </span><span class="cov8" title="1">{
                        // else normal
                        if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">stmt.Alternative = p.parseBlockStatement()</span>
                } else<span class="cov0" title="0"> {
                        // else if o elif - crear nuevo if statement
                        p.nextToken() // consume ELSE/ELIF
                        if p.curTokenIs(lexer.IF) </span><span class="cov0" title="0">{
                                p.nextToken() // consume IF si es else if
                        }</span>
                        // Crear un nuevo if statement para elif
                        <span class="cov0" title="0">elifStmt := &amp;ast.IfStatement{Token: p.curToken}
                        elifStmt.Condition = p.parseExpression(LOWEST)
                        // Skip newlines
                        for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                                p.nextToken()
                        }</span>
                        <span class="cov0" title="0">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">elifStmt.Consequence = p.parseBlockStatement()
                        stmt.Alternative = &amp;ast.BlockStatement{
                                Token: p.curToken,
                                Statements: []ast.Statement{elifStmt},
                        }</span>
                }
        }

        <span class="cov8" title="1">return stmt</span>
}

        // parseForStatement analiza una sentencia 'for in'
        func (p *Parser) parseForStatement() ast.Statement <span class="cov0" title="0">{
                token := p.curToken // FOR token
        
                // Determinar tipo de for loop
                if p.peekTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        // Podría ser for-in: for x in array
                        p.nextToken() // consume FOR
                        identifier := p.curToken
        
                        if p.peekTokenIs(lexer.IN) </span><span class="cov0" title="0">{
                                return p.parseForInStatement(token, identifier)
                        }</span> else<span class="cov0" title="0"> {
                                // for tradicional: for i = 0; i &lt; 10; i++
                                return p.parseTraditionalForStatement(token)
                        }</span>
                }
        
                // for con paréntesis: for (i = 0; i &lt; 10; i++)
                <span class="cov0" title="0">return p.parseTraditionalForStatement(token)</span>
        }
        
        func (p *Parser) parseForInStatement(forToken lexer.Token, identifier lexer.Token) *ast.ForInStatement <span class="cov0" title="0">{
                stmt := &amp;ast.ForInStatement{Token: forToken}
                stmt.Identifier = &amp;ast.Identifier{Token: identifier, Value: identifier.Lexeme}
        
                if !p.expectPeek(lexer.IN) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        
                <span class="cov0" title="0">p.nextToken()
                stmt.Iterable = p.parseExpression(LOWEST)
        
                // Skip newlines
                for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>
        
                <span class="cov0" title="0">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        
                <span class="cov0" title="0">stmt.Body = p.parseBlockStatement()
                return stmt</span>
        }
        
        func (p *Parser) parseTraditionalForStatement(forToken lexer.Token) ast.Statement <span class="cov0" title="0">{
                // Por ahora, devolver un statement vacío
                // TODO: Implementar for tradicional
                return &amp;ast.ExpressionStatement{
                        Token: forToken,
                        Expression: &amp;ast.Identifier{Token: forToken, Value: "FOR_LOOP"},
                }
        }</span>

        // parseClassStatement analiza una declaración de clase
        func (p *Parser) parseClassStatement() *ast.ClassStatement <span class="cov0" title="0">{
                stmt := &amp;ast.ClassStatement{Token: p.curToken}
        
                if !p.expectPeek(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}
        
                // CRÍTICO: Avanzar después del nombre de la clase
                p.nextToken()
        
                // Skip newlines antes de {
                for p.curTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>
        
                // ARREGLO: Verificar que estamos en LEFT_BRACE antes de continuar
                <span class="cov0" title="0">if !p.curTokenIs(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                        p.addError(fmt.Sprintf("expected '{' after class name, got %s", p.curToken.Type))
                        return nil
                }</span>
        
                // Parse class body
                <span class="cov0" title="0">p.nextToken() // consume {
        
                for p.curToken.Type != lexer.RIGHT_BRACE &amp;&amp; p.curToken.Type != lexer.EOF </span><span class="cov0" title="0">{
                        if p.curTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                                p.nextToken()
                                continue</span>
                        }
        
                        <span class="cov0" title="0">switch p.curToken.Type </span>{
                        case lexer.VAR:<span class="cov0" title="0">
                                attr := p.parseVarStatement()
                                if attr != nil </span><span class="cov0" title="0">{
                                        if stmt.Attributes == nil </span><span class="cov0" title="0">{
                                                stmt.Attributes = []*ast.VarStatement{}
                                        }</span>
                                        <span class="cov0" title="0">stmt.Attributes = append(stmt.Attributes, attr)</span>
                                }
                        case lexer.FUNC:<span class="cov0" title="0">
                                method := p.parseFunctionStatement()
                                if method != nil </span><span class="cov0" title="0">{
                                        if stmt.Methods == nil </span><span class="cov0" title="0">{
                                                stmt.Methods = []*ast.FuncStatement{}
                                        }</span>
                                        <span class="cov0" title="0">stmt.Methods = append(stmt.Methods, method)
                                        if method.Name != nil &amp;&amp; method.Name.Value == "init" </span><span class="cov0" title="0">{
                                                stmt.InitMethod = method
                                        }</span>
                                }
                        default:<span class="cov0" title="0">
                                // Skip tokens desconocidos sin error
                                p.nextToken()</span>
                        }
                }
        
                <span class="cov0" title="0">if p.curTokenIs(lexer.RIGHT_BRACE) </span><span class="cov0" title="0">{
                        p.nextToken() // consume }
                }</span>
        
                <span class="cov0" title="0">return stmt</span>
        }

        func (p *Parser) parseTryStatement() *ast.TryStatement <span class="cov0" title="0">{
                stmt := &amp;ast.TryStatement{Token: p.curToken}

                // Skip newlines after try
                for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>

                <span class="cov0" title="0">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">stmt.TryBlock = p.parseBlockStatement()

                // Skip newlines before catch
                for p.curTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>

                // CRÍTICO: Verificar que realmente es CATCH
                <span class="cov0" title="0">if p.curTokenIs(lexer.CATCH) </span><span class="cov0" title="0">{
                        stmt.CatchClause = &amp;ast.CatchClause{Token: p.curToken}

                        // Manejar parámetro opcional
                        if p.peekTokenIs(lexer.LEFT_PAREN) </span><span class="cov0" title="0">{
                                p.nextToken() // consume CATCH
                                p.nextToken() // consume (
                                if p.curTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                                        stmt.CatchClause.Parameter = &amp;ast.Identifier{
                                                Token: p.curToken,
                                                Value: p.curToken.Lexeme,
                                        }
                                }</span>
                                <span class="cov0" title="0">if !p.expectPeek(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                                        return nil
                                }</span>
                        } else<span class="cov0" title="0"> if p.peekTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                                p.nextToken() // consume CATCH
                                stmt.CatchClause.Parameter = &amp;ast.Identifier{
                                        Token: p.curToken,
                                        Value: p.curToken.Lexeme,
                                }
                        }</span> else<span class="cov0" title="0"> {
                                p.nextToken() // solo consume CATCH
                        }</span>

                        // Skip newlines before {
                        <span class="cov0" title="0">for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                                p.nextToken()
                        }</span>

                        <span class="cov0" title="0">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                                p.addError("expected '{' after catch")
                                return nil
                        }</span>

                        <span class="cov0" title="0">stmt.CatchClause.CatchBlock = p.parseBlockStatement()</span>
                }

                <span class="cov0" title="0">return stmt</span>
        }

        // parseThrowStatement analiza una sentencia 'throw'
        func (p *Parser) parseThrowStatement() *ast.ThrowStatement <span class="cov0" title="0">{
                stmt := &amp;ast.ThrowStatement{Token: p.curToken}

                p.nextToken() // consume THROW
                stmt.Exception = p.parseExpression(LOWEST)

                return stmt
        }</span>

        // parseThisExpression analiza una expresión 'this'
        func (p *Parser) parseThisExpression() ast.Expression <span class="cov0" title="0">{
                return &amp;ast.ThisExpression{Token: p.curToken}
        }</span>
        
        func (p *Parser) parseSuperExpression() ast.Expression <span class="cov0" title="0">{
                return &amp;ast.Identifier{Token: p.curToken, Value: "super"}
        }</span>
        
        func (p *Parser) parseFunctionLiteral() ast.Expression <span class="cov0" title="0">{
                // Para funciones anónimas: func(a, b) { return a + b }
                return &amp;ast.Identifier{Token: p.curToken, Value: "FUNCTION_LITERAL"}
        }</span>
        
        func (p *Parser) parseHashLiteral() ast.Expression <span class="cov0" title="0">{
                hash := &amp;ast.HashLiteral{Token: p.curToken, Pairs: make(map[ast.Expression]ast.Expression)}

                // Hash vacío {}
                if p.peekTokenIs(lexer.RIGHT_BRACE) </span><span class="cov0" title="0">{
                        p.nextToken() // consume }
                        return hash
                }</span>

                <span class="cov0" title="0">p.nextToken() // consume {

                for !p.curTokenIs(lexer.RIGHT_BRACE) </span><span class="cov0" title="0">{
                        key := p.parseExpression(LOWEST)
                        if key == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if !p.expectPeek(lexer.COLON) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">p.nextToken() // consume :
                        value := p.parseExpression(LOWEST)
                        if value == nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">hash.Pairs[key] = value

                        if p.peekTokenIs(lexer.COMMA) </span><span class="cov0" title="0">{
                                p.nextToken() // consume ,
                        }</span> else<span class="cov0" title="0"> if !p.peekTokenIs(lexer.RIGHT_BRACE) </span><span class="cov0" title="0">{
                                p.addError("expected ',' or '}' in hash literal")
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">if !p.expectPeek(lexer.RIGHT_BRACE) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">return hash</span>
        }


        // Precedence constants
        const (
                LOWEST int = iota
                ASSIGN
                EQUALS
                COMPARES
                SUM
                PRODUCT
                PREFIX
                CALL
                INDEX
        )

// AGREGAR manejo de precedencias para nuevos operadores:
var precedences = map[lexer.TokenType]int{
        lexer.EQUAL:         ASSIGN,
        lexer.OR:            EQUALS,
        lexer.AND:           COMPARES,
        lexer.EQUAL_EQUAL:   EQUALS,
        lexer.BANG_EQUAL:    EQUALS,
        lexer.LESS:          COMPARES,
        lexer.LESS_EQUAL:    COMPARES,
        lexer.GREATER:       COMPARES,
        lexer.GREATER_EQUAL: COMPARES,
        lexer.PLUS:          SUM,
        lexer.MINUS:         SUM,
        lexer.STAR:          PRODUCT,
        lexer.SLASH:         PRODUCT,
        lexer.PERCENT:       PRODUCT,
        lexer.LEFT_PAREN:    CALL,
        lexer.LEFT_BRACKET:  INDEX,
        lexer.DOT:           CALL,
}

        // parseFunctionStatement analiza una declaración de función
        func (p *Parser) parseFunctionStatement() *ast.FuncStatement <span class="cov0" title="0">{
                stmt := &amp;ast.FuncStatement{Token: p.curToken}

                p.nextToken() // consume FUNC

                // Parse function name
                if !p.curTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                        p.addError("expected function name after 'func'")
                        return nil
                }</span>
                <span class="cov0" title="0">stmt.Name = &amp;ast.Identifier{Token: p.curToken, Value: p.curToken.Lexeme}
                p.nextToken() // consume function name

                // Parse parameters
                if !p.curTokenIs(lexer.LEFT_PAREN) </span><span class="cov0" title="0">{
                        p.addError("expected '(' after function name")
                        return nil
                }</span>
                <span class="cov0" title="0">p.nextToken() // consume (
                stmt.Parameters = []*ast.Identifier{}

                for !p.curTokenIs(lexer.RIGHT_PAREN) &amp;&amp; !p.curTokenIs(lexer.EOF) </span><span class="cov0" title="0">{
                        if p.curTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                                param := &amp;ast.Identifier{
                                        Token: p.curToken,
                                        Value: p.curToken.Lexeme,
                                }
                                stmt.Parameters = append(stmt.Parameters, param)
                                p.nextToken()

                                // Skip comma if present
                                if p.curTokenIs(lexer.COMMA) </span><span class="cov0" title="0">{
                                        p.nextToken()
                                }</span>
                        } else<span class="cov0" title="0"> if p.curTokenIs(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                                // Empty parameter list, just break
                                break</span>
                        } else<span class="cov0" title="0"> {
                                p.addError("expected parameter name")
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !p.curTokenIs(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                        p.addError("expected ')' after function parameters")
                        return nil
                }</span>
                <span class="cov0" title="0">p.nextToken() // consume )

                // Tipo de retorno opcional
                if p.peekTokenIs(lexer.COLON) </span><span class="cov0" title="0">{
                        p.nextToken() // consume :
                        if !p.curTokenIs(lexer.IDENTIFIER) </span><span class="cov0" title="0">{
                                p.addError("expected return type identifier, got " + string(p.curToken.Type))
                                return nil
                        }</span> else<span class="cov0" title="0"> {
                                stmt.ReturnType = p.curToken.Lexeme
                                p.nextToken()
                        }</span>
                }

                // Ignorar NEWLINE antes de '{'
                <span class="cov0" title="0">for p.curTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>

                // Cuerpo de la función
                <span class="cov0" title="0">if !p.curTokenIs(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                        p.addError("expected '{' to start function body")
                        return nil
                }</span>

                <span class="cov0" title="0">stmt.Body = p.parseBlockStatement()
                return stmt</span>
        }

        func (p *Parser) parseWhileStatement() *ast.WhileStatement <span class="cov0" title="0">{
                stmt := &amp;ast.WhileStatement{Token: p.curToken}

                p.nextToken() // consume WHILE

                // Manejar paréntesis opcionales explícitamente
                hasParens := false
                if p.curTokenIs(lexer.LEFT_PAREN) </span><span class="cov0" title="0">{
                        hasParens = true
                        p.nextToken() // consume '('
                }</span>

                <span class="cov0" title="0">stmt.Condition = p.parseExpression(LOWEST)

                // Si había paréntesis, consumir el ')'
                if hasParens </span><span class="cov0" title="0">{
                        if !p.expectPeek(lexer.RIGHT_PAREN) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                // Skip newlines before {
                <span class="cov0" title="0">for p.peekTokenIs(lexer.NEWLINE) </span><span class="cov0" title="0">{
                        p.nextToken()
                }</span>

                <span class="cov0" title="0">if !p.expectPeek(lexer.LEFT_BRACE) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">stmt.Body = p.parseBlockStatement()

                return stmt</span>
        }

</pre>
		
		<pre class="file" id="file8" style="display: none">package sema

import (
        "fmt"

        "github.com/zylo-lang/zylo/internal/ast"
)

// SymbolTable representa una tabla de símbolos para un ámbito específico.
type SymbolTable struct {
        parent     *SymbolTable
        symbols    map[string]*Symbol // Mapea nombres de identificadores a sus símbolos.
        scopeName  string
        scopeLevel int
}

// Symbol representa una entrada en la tabla de símbolos.
type Symbol struct {
        Name  string
        Type  string // Tipo del identificador (e.g., "int", "string", "any").
        Scope string // Ámbito en el que se definió.
}

// NewSymbolTable crea una nueva tabla de símbolos.
func NewSymbolTable(scopeName string, level int, parent *SymbolTable) *SymbolTable <span class="cov8" title="1">{
        return &amp;SymbolTable{
                parent:     parent,
                symbols:    make(map[string]*Symbol),
                scopeName:  scopeName,
                scopeLevel: level,
        }
}</span>

// Define añade un nuevo símbolo a la tabla de símbolos.
func (st *SymbolTable) Define(name string, symType string) *Symbol <span class="cov8" title="1">{
        symbol := &amp;Symbol{
                Name:  name,
                Type:  symType,
                Scope: fmt.Sprintf("%s (Level %d)", st.scopeName, st.scopeLevel),
        }
        st.symbols[name] = symbol
        return symbol
}</span>

// Resolve busca un símbolo en la tabla de símbolos actual y en sus padres.
func (st *SymbolTable) Resolve(name string) (*Symbol, bool) <span class="cov8" title="1">{
        if sym, ok := st.symbols[name]; ok </span><span class="cov8" title="1">{
                return sym, true
        }</span>
        <span class="cov8" title="1">if st.parent != nil </span><span class="cov8" title="1">{
                return st.parent.Resolve(name)
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}

// SemanticAnalyzer es el struct principal para el análisis semántico.
type SemanticAnalyzer struct {
        symbolTable *SymbolTable
        errors      []string
}

// NewSemanticAnalyzer crea un nuevo analizador semántico.
func NewSemanticAnalyzer() *SemanticAnalyzer <span class="cov8" title="1">{
        // Inicializar con una tabla de símbolos global.
        globalScope := NewSymbolTable("global", 0, nil)
        return &amp;SemanticAnalyzer{
                symbolTable: globalScope,
                errors:      []string{},
        }
}</span>

// Analyze ejecuta el análisis semántico sobre un AST.
func (sa *SemanticAnalyzer) Analyze(node ast.Node) <span class="cov8" title="1">{
        switch n := node.(type) </span>{
        case *ast.Program:<span class="cov8" title="1">
                for _, stmt := range n.Statements </span><span class="cov8" title="1">{
                        sa.Analyze(stmt) // Recursivamente analizar cada sentencia.
                }</span>
        case *ast.VarStatement:<span class="cov8" title="1">
                // Definir la variable en la tabla de símbolos.
                // Por ahora, asumimos tipo "any" por defecto.
                sa.symbolTable.Define(n.Name.Value, "any")
                // Analizar el valor de la expresión y su tipo.
                if n.Value != nil </span><span class="cov8" title="1">{
                        sa.Analyze(n.Value)
                }</span>
        case *ast.ExpressionStatement:<span class="cov8" title="1">
                sa.Analyze(n.Expression)</span>
        case *ast.Identifier:<span class="cov8" title="1">
                // Al encontrar un identificador, verificar si está definido.
                if _, ok := sa.symbolTable.Resolve(n.Value); !ok </span><span class="cov8" title="1">{
                        sa.addError(fmt.Sprintf("identifier not found: %s", n.Value))
                }</span>
        case *ast.FuncStatement:<span class="cov8" title="1">
                // Registrar la función en la tabla de símbolos.
                // Por ahora, el tipo de la función es genérico "func".
                sa.symbolTable.Define(n.Name.Value, "func")
                // Analizar el cuerpo de la función en un nuevo scope.
                sa.enterScope(n.Name.Value)
                // Registrar los parámetros de la función en el nuevo scope
                for _, param := range n.Parameters </span><span class="cov8" title="1">{
                        sa.symbolTable.Define(param.Value, "any") // Usar param.Value ya que es *ast.Identifier
                }</span>
                <span class="cov8" title="1">sa.Analyze(n.Body)
                sa.exitScope()</span>
        case *ast.BlockStatement:<span class="cov8" title="1">
                // Analizar cada sentencia dentro del bloque.
                for _, stmt := range n.Statements </span><span class="cov8" title="1">{
                        sa.Analyze(stmt)
                }</span>
        case *ast.CallExpression:<span class="cov8" title="1">
                // Analizar la función y los argumentos
                sa.Analyze(n.Function)
                for _, arg := range n.Arguments </span><span class="cov8" title="1">{
                        sa.Analyze(arg)
                }</span>
        case *ast.InfixExpression:<span class="cov8" title="1">
                // Analizar las expresiones izquierda y derecha
                sa.Analyze(n.Left)
                sa.Analyze(n.Right)</span>
        case *ast.PrefixExpression:<span class="cov0" title="0">
                // Analizar la expresión derecha
                sa.Analyze(n.Right)</span>
        case *ast.NumberLiteral, *ast.StringLiteral, *ast.BooleanLiteral:<span class="cov8" title="1"></span>
                // Los literales no necesitan análisis semántico adicional
                // TODO: Añadir manejo para otros tipos de nodos (ClassDecl, IfStmt, WhileStmt, etc.)
        }
}

// enterScope crea un nuevo ámbito y lo establece como el ámbito actual.
func (sa *SemanticAnalyzer) enterScope(name string) <span class="cov8" title="1">{
        newScope := NewSymbolTable(name, sa.symbolTable.scopeLevel+1, sa.symbolTable)
        sa.symbolTable = newScope
}</span>

// exitScope sale del ámbito actual y vuelve al ámbito padre.
func (sa *SemanticAnalyzer) exitScope() <span class="cov8" title="1">{
        if sa.symbolTable.parent != nil </span><span class="cov8" title="1">{
                sa.symbolTable = sa.symbolTable.parent
        }</span>
}

// addError añade un error de análisis semántico.
func (sa *SemanticAnalyzer) addError(msg string) <span class="cov8" title="1">{
        sa.errors = append(sa.errors, msg)
}</span>

// Errors devuelve los errores encontrados.
func (sa *SemanticAnalyzer) Errors() []string <span class="cov8" title="1">{
        return sa.errors
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package zyloruntime

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "os"
        "strconv"
        "time"
)

// Println es una función de runtime para imprimir en la consola.
// Corresponde a la función 'print' en Zylo.
func Println(a ...interface{}) <span class="cov0" title="0">{
        fmt.Println(a...)
}</span>

// Print es una función de runtime para imprimir sin nueva línea.
func Print(a ...interface{}) <span class="cov0" title="0">{
        fmt.Print(a...)
}</span>

// Printf es una función de runtime para imprimir con formato.
func Printf(format string, a ...interface{}) <span class="cov0" title="0">{
        fmt.Printf(format, a...)
}</span>

// Exit es una función de runtime para terminar el programa.
func Exit(code int) <span class="cov0" title="0">{
        os.Exit(code)
}</span>

// --- Manejo de Errores y Excepciones ---

// ZyloError representa un error en Zylo.
type ZyloError struct {
        Message string
}

// Error implementa la interfaz error.
func (e *ZyloError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Throw lanza una excepción Zylo.
func Throw(message string) <span class="cov0" title="0">{
        panic(&amp;ZyloError{Message: message})</span>
}

// Try ejecuta una función y captura excepciones.
func Try(fn func(), catch func(error)) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if err, ok := r.(*ZyloError); ok </span><span class="cov0" title="0">{
                                catch(err)
                        }</span> else<span class="cov0" title="0"> {
                                // Re-panic para errores no-Zylo
                                panic(r)</span>
                        }
                }
        }()
        <span class="cov0" title="0">fn()</span>
}

// --- Estructuras de Datos ---

// List representa una lista dinámica.
type List struct {
        items []interface{}
}

// NewList crea una nueva lista.
func NewList() *List <span class="cov0" title="0">{
        return &amp;List{items: make([]interface{}, 0)}
}</span>

// Append añade un elemento al final de la lista.
func (l *List) Append(item interface{}) <span class="cov0" title="0">{
        l.items = append(l.items, item)
}</span>

// Get obtiene un elemento por índice.
func (l *List) Get(index int) interface{} <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= len(l.items) </span><span class="cov0" title="0">{
                Throw("Index out of bounds")
        }</span>
        <span class="cov0" title="0">return l.items[index]</span>
}

// Set establece un elemento en un índice.
func (l *List) Set(index int, item interface{}) <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= len(l.items) </span><span class="cov0" title="0">{
                Throw("Index out of bounds")
        }</span>
        <span class="cov0" title="0">l.items[index] = item</span>
}

// Len devuelve la longitud de la lista.
func (l *List) Len() int <span class="cov0" title="0">{
        return len(l.items)
}</span>

// Map representa un mapa de clave-valor.
type Map struct {
        items map[string]interface{}
}

// NewMap crea un nuevo mapa.
func NewMap() *Map <span class="cov0" title="0">{
        return &amp;Map{items: make(map[string]interface{})}
}</span>

// Set establece un valor para una clave.
func (m *Map) Set(key string, value interface{}) <span class="cov0" title="0">{
        m.items[key] = value
}</span>

// Get obtiene un valor por clave.
func (m *Map) Get(key string) interface{} <span class="cov0" title="0">{
        return m.items[key]
}</span>

// Has verifica si una clave existe.
func (m *Map) Has(key string) bool <span class="cov0" title="0">{
        _, exists := m.items[key]
        return exists
}</span>

// Delete elimina una clave.
func (m *Map) Delete(key string) <span class="cov0" title="0">{
        delete(m.items, key)
}</span>

// Keys devuelve todas las claves.
func (m *Map) Keys() []string <span class="cov0" title="0">{
        keys := make([]string, 0, len(m.items))
        for k := range m.items </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// --- I/O y Filesystem ---

// ReadFile lee el contenido completo de un archivo.
func ReadFile(filename string) string <span class="cov0" title="0">{
        content, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                Throw(fmt.Sprintf("Error reading file: %v", err))
        }</span>
        <span class="cov0" title="0">return string(content)</span>
}

// WriteFile escribe contenido a un archivo.
func WriteFile(filename string, content string) <span class="cov0" title="0">{
        err := ioutil.WriteFile(filename, []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                Throw(fmt.Sprintf("Error writing file: %v", err))
        }</span>
}

// FileExists verifica si un archivo existe.
func FileExists(filename string) bool <span class="cov0" title="0">{
        _, err := os.Stat(filename)
        return !os.IsNotExist(err)
}</span>

// --- JSON ---

// ToJSON convierte un valor a JSON string.
func ToJSON(value interface{}) string <span class="cov0" title="0">{
        jsonBytes, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                Throw(fmt.Sprintf("Error converting to JSON: %v", err))
        }</span>
        <span class="cov0" title="0">return string(jsonBytes)</span>
}

// FromJSON convierte un JSON string a un valor.
func FromJSON(jsonStr string) interface{} <span class="cov0" title="0">{
        var result interface{}
        err := json.Unmarshal([]byte(jsonStr), &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                Throw(fmt.Sprintf("Error parsing JSON: %v", err))
        }</span>
        <span class="cov0" title="0">return result</span>
}

// --- Time y Utilidades ---

// Now devuelve la hora actual como timestamp.
func Now() int64 <span class="cov0" title="0">{
        return time.Now().Unix()
}</span>

// Sleep pausa la ejecución por milisegundos.
func Sleep(milliseconds int) <span class="cov0" title="0">{
        time.Sleep(time.Duration(milliseconds) * time.Millisecond)
}</span>

// Random devuelve un número aleatorio entre 0 y max-1.
func Random(max int) int <span class="cov0" title="0">{
        return int(time.Now().UnixNano()) % max
}</span>

// --- Funciones Matemáticas ---

// Abs devuelve el valor absoluto de un número.
func Abs(x int) int <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}

// Max devuelve el máximo de dos números.
func Max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// Min devuelve el mínimo de dos números.
func Min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// --- Input/Output ---

// ReadLine lee una línea de entrada del usuario.
func ReadLine() string <span class="cov0" title="0">{
        var input string
        fmt.Scanln(&amp;input)
        return input
}</span>

// ReadInt lee un número entero del usuario.
func ReadInt() int <span class="cov0" title="0">{
        var input int
        fmt.Scanf("%d", &amp;input)
        return input
}</span>

// --- String Utilities ---

// StrLen devuelve la longitud de una cadena.
func StrLen(s string) int <span class="cov0" title="0">{
        return len(s)
}</span>

// StrSplit divide una cadena por un separador.
func StrSplit(s, sep string) []string <span class="cov0" title="0">{
        // Implementación simple
        result := []string{}
        current := ""
        for _, char := range s </span><span class="cov0" title="0">{
                if string(char) == sep </span><span class="cov0" title="0">{
                        result = append(result, current)
                        current = ""
                }</span> else<span class="cov0" title="0"> {
                        current += string(char)
                }</span>
        }
        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                result = append(result, current)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// StrJoin une una lista de cadenas con un separador.
func StrJoin(parts []string, sep string) string <span class="cov0" title="0">{
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">result := parts[0]
        for i := 1; i &lt; len(parts); i++ </span><span class="cov0" title="0">{
                result += sep + parts[i]
        }</span>
        <span class="cov0" title="0">return result</span>
}

// ToNumber convierte un string a número, retorna nil si falla.
func ToNumber(s string) interface{} <span class="cov0" title="0">{
        f, err := strconv.ParseFloat(s, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f</span>
}

// String convierte cualquier valor a string.
func String(x interface{}) string <span class="cov0" title="0">{
        return fmt.Sprintf("%v", x)
}</span>

// Split divide un string y retorna una lista de substrings.
func Split(s, sep string) *List <span class="cov0" title="0">{
        result := NewList()
        current := ""
        for _, char := range s </span><span class="cov0" title="0">{
                if string(char) == sep </span><span class="cov0" title="0">{
                        result.Append(current)
                        current = ""
                }</span> else<span class="cov0" title="0"> {
                        current += string(char)
                }</span>
        }
        <span class="cov0" title="0">if current != "" </span><span class="cov0" title="0">{
                result.Append(current)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Add suma dos números.
func Add(a, b float64) float64 <span class="cov0" title="0">{
        return a + b
}</span>

// Subtract resta dos números.
func Subtract(a, b float64) float64 <span class="cov0" title="0">{
        return a - b
}</span>

// Multiply multiplica dos números.
func Multiply(a, b float64) float64 <span class="cov0" title="0">{
        return a * b
}</span>

// Divide divide dos números, lanza error si divisor es cero.
func Divide(a, b float64) float64 <span class="cov0" title="0">{
        if b == 0 </span><span class="cov0" title="0">{
                Throw("Division by zero")
        }</span>
        <span class="cov0" title="0">return a / b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "os"
        "testing"

        "github.com/zylo-lang/zylo/internal/evaluator"
        "github.com/zylo-lang/zylo/internal/lexer"
        "github.com/zylo-lang/zylo/internal/parser"
)

func TestCalculator(t *testing.T) <span class="cov0" title="0">{
        // Leer archivo calculator.zylo
        content, err := os.ReadFile("examples/calculator.zylo")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Error leyendo archivo: %v", err)
        }</span>

        <span class="cov0" title="0">t.Log("🚀 Ejecutando calculadora Zylo...")
        t.Log("=================================")

        // Parsear
        l := lexer.New(string(content))
        p := parser.New(l)
        program := p.ParseProgram()

        if len(p.Errors()) &gt; 0 </span><span class="cov0" title="0">{
                t.Log("Errores de parsing:")
                for _, err := range p.Errors() </span><span class="cov0" title="0">{
                        t.Errorf("  %s", err)
                }</span>
                <span class="cov0" title="0">t.Fatal("Errores de parsing")</span>
        }

        // Ejecutar con el evaluador
        <span class="cov0" title="0">eval := evaluator.NewEvaluator()
        err = eval.EvaluateProgram(program)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Error de ejecución: %v", err)
        }</span>

        <span class="cov0" title="0">t.Log("\n✅ ¡Calculadora ejecutada exitosamente!")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
